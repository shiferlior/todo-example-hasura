/* DO NOT EDIT! This file is auto-generated by graphql-code-generator - see `codegen.yml` */
import { useQuery, QueryConfig } from 'react-query';
export type Maybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };

function fetcher<TData, TVariables>(endpoint: string, requestInit: RequestInit, query: string, variables?: TVariables) {
  return async (): Promise<TData> => {
    const res = await fetch(endpoint, {
      method: 'POST',
      ...requestInit,
      body: JSON.stringify({ query, variables }),
    });

    const json = await res.json();

    if (json.errors) {
      const { message } = json.errors[0];

      throw new Error(message);
    }

    return json.data;
  }
}
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  date: any;
  float8: any;
  money: any;
  timestamptz: any;
};

/** expression to compare columns of type Boolean. All fields are combined with logical 'AND'. */
export type Boolean_Comparison_Exp = {
  _eq?: Maybe<Scalars['Boolean']>;
  _gt?: Maybe<Scalars['Boolean']>;
  _gte?: Maybe<Scalars['Boolean']>;
  _in?: Maybe<Array<Scalars['Boolean']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['Boolean']>;
  _lte?: Maybe<Scalars['Boolean']>;
  _neq?: Maybe<Scalars['Boolean']>;
  _nin?: Maybe<Array<Scalars['Boolean']>>;
};

/** expression to compare columns of type Int. All fields are combined with logical 'AND'. */
export type Int_Comparison_Exp = {
  _eq?: Maybe<Scalars['Int']>;
  _gt?: Maybe<Scalars['Int']>;
  _gte?: Maybe<Scalars['Int']>;
  _in?: Maybe<Array<Scalars['Int']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['Int']>;
  _lte?: Maybe<Scalars['Int']>;
  _neq?: Maybe<Scalars['Int']>;
  _nin?: Maybe<Array<Scalars['Int']>>;
};

/** expression to compare columns of type String. All fields are combined with logical 'AND'. */
export type String_Comparison_Exp = {
  _eq?: Maybe<Scalars['String']>;
  _gt?: Maybe<Scalars['String']>;
  _gte?: Maybe<Scalars['String']>;
  _ilike?: Maybe<Scalars['String']>;
  _in?: Maybe<Array<Scalars['String']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _like?: Maybe<Scalars['String']>;
  _lt?: Maybe<Scalars['String']>;
  _lte?: Maybe<Scalars['String']>;
  _neq?: Maybe<Scalars['String']>;
  _nilike?: Maybe<Scalars['String']>;
  _nin?: Maybe<Array<Scalars['String']>>;
  _nlike?: Maybe<Scalars['String']>;
  _nsimilar?: Maybe<Scalars['String']>;
  _similar?: Maybe<Scalars['String']>;
};

/** columns and relationships of "contracts" */
export type Contracts = {
  __typename?: 'contracts';
  arnonaPayByRenters?: Maybe<Scalars['Boolean']>;
  created_at: Scalars['timestamptz'];
  electricityPayByRenters?: Maybe<Scalars['Boolean']>;
  endDate?: Maybe<Scalars['date']>;
  gasPayByRenters?: Maybe<Scalars['Boolean']>;
  id: Scalars['Int'];
  internetPayByRenters?: Maybe<Scalars['Boolean']>;
  linkToS3?: Maybe<Scalars['String']>;
  /** An array relationship */
  payments: Array<Payments>;
  /** An aggregated array relationship */
  payments_aggregate: Payments_Aggregate;
  /** An object relationship */
  property: Properties;
  propertyId: Scalars['Int'];
  startDate?: Maybe<Scalars['date']>;
  /** An array relationship */
  tickets: Array<Tickets>;
  /** An aggregated array relationship */
  tickets_aggregate: Tickets_Aggregate;
  updated_at: Scalars['timestamptz'];
  vaadPayByRenters?: Maybe<Scalars['Boolean']>;
  waterPayByRenters?: Maybe<Scalars['Boolean']>;
};


/** columns and relationships of "contracts" */
export type ContractsPaymentsArgs = {
  distinct_on?: Maybe<Array<Payments_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Payments_Order_By>>;
  where?: Maybe<Payments_Bool_Exp>;
};


/** columns and relationships of "contracts" */
export type ContractsPayments_AggregateArgs = {
  distinct_on?: Maybe<Array<Payments_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Payments_Order_By>>;
  where?: Maybe<Payments_Bool_Exp>;
};


/** columns and relationships of "contracts" */
export type ContractsTicketsArgs = {
  distinct_on?: Maybe<Array<Tickets_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tickets_Order_By>>;
  where?: Maybe<Tickets_Bool_Exp>;
};


/** columns and relationships of "contracts" */
export type ContractsTickets_AggregateArgs = {
  distinct_on?: Maybe<Array<Tickets_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tickets_Order_By>>;
  where?: Maybe<Tickets_Bool_Exp>;
};

/** columns and relationships of "contractsRentersRelation" */
export type ContractsRentersRelation = {
  __typename?: 'contractsRentersRelation';
  contractId: Scalars['Int'];
  /** An object relationship */
  entity: Entities;
  /** An object relationship */
  entityByRenterId: Entities;
  guarantorId: Scalars['Int'];
  guatantyAmount?: Maybe<Scalars['float8']>;
  propertySection: Scalars['String'];
  renterId: Scalars['Int'];
};

/** aggregated selection of "contractsRentersRelation" */
export type ContractsRentersRelation_Aggregate = {
  __typename?: 'contractsRentersRelation_aggregate';
  aggregate?: Maybe<ContractsRentersRelation_Aggregate_Fields>;
  nodes: Array<ContractsRentersRelation>;
};

/** aggregate fields of "contractsRentersRelation" */
export type ContractsRentersRelation_Aggregate_Fields = {
  __typename?: 'contractsRentersRelation_aggregate_fields';
  avg?: Maybe<ContractsRentersRelation_Avg_Fields>;
  count?: Maybe<Scalars['Int']>;
  max?: Maybe<ContractsRentersRelation_Max_Fields>;
  min?: Maybe<ContractsRentersRelation_Min_Fields>;
  stddev?: Maybe<ContractsRentersRelation_Stddev_Fields>;
  stddev_pop?: Maybe<ContractsRentersRelation_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<ContractsRentersRelation_Stddev_Samp_Fields>;
  sum?: Maybe<ContractsRentersRelation_Sum_Fields>;
  var_pop?: Maybe<ContractsRentersRelation_Var_Pop_Fields>;
  var_samp?: Maybe<ContractsRentersRelation_Var_Samp_Fields>;
  variance?: Maybe<ContractsRentersRelation_Variance_Fields>;
};


/** aggregate fields of "contractsRentersRelation" */
export type ContractsRentersRelation_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<ContractsRentersRelation_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "contractsRentersRelation" */
export type ContractsRentersRelation_Aggregate_Order_By = {
  avg?: Maybe<ContractsRentersRelation_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<ContractsRentersRelation_Max_Order_By>;
  min?: Maybe<ContractsRentersRelation_Min_Order_By>;
  stddev?: Maybe<ContractsRentersRelation_Stddev_Order_By>;
  stddev_pop?: Maybe<ContractsRentersRelation_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<ContractsRentersRelation_Stddev_Samp_Order_By>;
  sum?: Maybe<ContractsRentersRelation_Sum_Order_By>;
  var_pop?: Maybe<ContractsRentersRelation_Var_Pop_Order_By>;
  var_samp?: Maybe<ContractsRentersRelation_Var_Samp_Order_By>;
  variance?: Maybe<ContractsRentersRelation_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "contractsRentersRelation" */
export type ContractsRentersRelation_Arr_Rel_Insert_Input = {
  data: Array<ContractsRentersRelation_Insert_Input>;
  on_conflict?: Maybe<ContractsRentersRelation_On_Conflict>;
};

/** aggregate avg on columns */
export type ContractsRentersRelation_Avg_Fields = {
  __typename?: 'contractsRentersRelation_avg_fields';
  contractId?: Maybe<Scalars['Float']>;
  guarantorId?: Maybe<Scalars['Float']>;
  guatantyAmount?: Maybe<Scalars['Float']>;
  renterId?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "contractsRentersRelation" */
export type ContractsRentersRelation_Avg_Order_By = {
  contractId?: Maybe<Order_By>;
  guarantorId?: Maybe<Order_By>;
  guatantyAmount?: Maybe<Order_By>;
  renterId?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "contractsRentersRelation". All fields are combined with a logical 'AND'. */
export type ContractsRentersRelation_Bool_Exp = {
  _and?: Maybe<Array<Maybe<ContractsRentersRelation_Bool_Exp>>>;
  _not?: Maybe<ContractsRentersRelation_Bool_Exp>;
  _or?: Maybe<Array<Maybe<ContractsRentersRelation_Bool_Exp>>>;
  contractId?: Maybe<Int_Comparison_Exp>;
  entity?: Maybe<Entities_Bool_Exp>;
  entityByRenterId?: Maybe<Entities_Bool_Exp>;
  guarantorId?: Maybe<Int_Comparison_Exp>;
  guatantyAmount?: Maybe<Float8_Comparison_Exp>;
  propertySection?: Maybe<String_Comparison_Exp>;
  renterId?: Maybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "contractsRentersRelation" */
export enum ContractsRentersRelation_Constraint {
  /** unique or primary key constraint */
  ContractsRentersRelationPkey = 'contracts_renters_relation_pkey'
}

/** input type for incrementing integer column in table "contractsRentersRelation" */
export type ContractsRentersRelation_Inc_Input = {
  contractId?: Maybe<Scalars['Int']>;
  guarantorId?: Maybe<Scalars['Int']>;
  guatantyAmount?: Maybe<Scalars['float8']>;
  renterId?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "contractsRentersRelation" */
export type ContractsRentersRelation_Insert_Input = {
  contractId?: Maybe<Scalars['Int']>;
  entity?: Maybe<Entities_Obj_Rel_Insert_Input>;
  entityByRenterId?: Maybe<Entities_Obj_Rel_Insert_Input>;
  guarantorId?: Maybe<Scalars['Int']>;
  guatantyAmount?: Maybe<Scalars['float8']>;
  propertySection?: Maybe<Scalars['String']>;
  renterId?: Maybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type ContractsRentersRelation_Max_Fields = {
  __typename?: 'contractsRentersRelation_max_fields';
  contractId?: Maybe<Scalars['Int']>;
  guarantorId?: Maybe<Scalars['Int']>;
  guatantyAmount?: Maybe<Scalars['float8']>;
  propertySection?: Maybe<Scalars['String']>;
  renterId?: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "contractsRentersRelation" */
export type ContractsRentersRelation_Max_Order_By = {
  contractId?: Maybe<Order_By>;
  guarantorId?: Maybe<Order_By>;
  guatantyAmount?: Maybe<Order_By>;
  propertySection?: Maybe<Order_By>;
  renterId?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type ContractsRentersRelation_Min_Fields = {
  __typename?: 'contractsRentersRelation_min_fields';
  contractId?: Maybe<Scalars['Int']>;
  guarantorId?: Maybe<Scalars['Int']>;
  guatantyAmount?: Maybe<Scalars['float8']>;
  propertySection?: Maybe<Scalars['String']>;
  renterId?: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "contractsRentersRelation" */
export type ContractsRentersRelation_Min_Order_By = {
  contractId?: Maybe<Order_By>;
  guarantorId?: Maybe<Order_By>;
  guatantyAmount?: Maybe<Order_By>;
  propertySection?: Maybe<Order_By>;
  renterId?: Maybe<Order_By>;
};

/** response of any mutation on the table "contractsRentersRelation" */
export type ContractsRentersRelation_Mutation_Response = {
  __typename?: 'contractsRentersRelation_mutation_response';
  /** number of affected rows by the mutation */
  affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  returning: Array<ContractsRentersRelation>;
};

/** input type for inserting object relation for remote table "contractsRentersRelation" */
export type ContractsRentersRelation_Obj_Rel_Insert_Input = {
  data: ContractsRentersRelation_Insert_Input;
  on_conflict?: Maybe<ContractsRentersRelation_On_Conflict>;
};

/** on conflict condition type for table "contractsRentersRelation" */
export type ContractsRentersRelation_On_Conflict = {
  constraint: ContractsRentersRelation_Constraint;
  update_columns: Array<ContractsRentersRelation_Update_Column>;
  where?: Maybe<ContractsRentersRelation_Bool_Exp>;
};

/** ordering options when selecting data from "contractsRentersRelation" */
export type ContractsRentersRelation_Order_By = {
  contractId?: Maybe<Order_By>;
  entity?: Maybe<Entities_Order_By>;
  entityByRenterId?: Maybe<Entities_Order_By>;
  guarantorId?: Maybe<Order_By>;
  guatantyAmount?: Maybe<Order_By>;
  propertySection?: Maybe<Order_By>;
  renterId?: Maybe<Order_By>;
};

/** primary key columns input for table: "contractsRentersRelation" */
export type ContractsRentersRelation_Pk_Columns_Input = {
  contractId: Scalars['Int'];
  renterId: Scalars['Int'];
};

/** select columns of table "contractsRentersRelation" */
export enum ContractsRentersRelation_Select_Column {
  /** column name */
  ContractId = 'contractId',
  /** column name */
  GuarantorId = 'guarantorId',
  /** column name */
  GuatantyAmount = 'guatantyAmount',
  /** column name */
  PropertySection = 'propertySection',
  /** column name */
  RenterId = 'renterId'
}

/** input type for updating data in table "contractsRentersRelation" */
export type ContractsRentersRelation_Set_Input = {
  contractId?: Maybe<Scalars['Int']>;
  guarantorId?: Maybe<Scalars['Int']>;
  guatantyAmount?: Maybe<Scalars['float8']>;
  propertySection?: Maybe<Scalars['String']>;
  renterId?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type ContractsRentersRelation_Stddev_Fields = {
  __typename?: 'contractsRentersRelation_stddev_fields';
  contractId?: Maybe<Scalars['Float']>;
  guarantorId?: Maybe<Scalars['Float']>;
  guatantyAmount?: Maybe<Scalars['Float']>;
  renterId?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "contractsRentersRelation" */
export type ContractsRentersRelation_Stddev_Order_By = {
  contractId?: Maybe<Order_By>;
  guarantorId?: Maybe<Order_By>;
  guatantyAmount?: Maybe<Order_By>;
  renterId?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type ContractsRentersRelation_Stddev_Pop_Fields = {
  __typename?: 'contractsRentersRelation_stddev_pop_fields';
  contractId?: Maybe<Scalars['Float']>;
  guarantorId?: Maybe<Scalars['Float']>;
  guatantyAmount?: Maybe<Scalars['Float']>;
  renterId?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "contractsRentersRelation" */
export type ContractsRentersRelation_Stddev_Pop_Order_By = {
  contractId?: Maybe<Order_By>;
  guarantorId?: Maybe<Order_By>;
  guatantyAmount?: Maybe<Order_By>;
  renterId?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type ContractsRentersRelation_Stddev_Samp_Fields = {
  __typename?: 'contractsRentersRelation_stddev_samp_fields';
  contractId?: Maybe<Scalars['Float']>;
  guarantorId?: Maybe<Scalars['Float']>;
  guatantyAmount?: Maybe<Scalars['Float']>;
  renterId?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "contractsRentersRelation" */
export type ContractsRentersRelation_Stddev_Samp_Order_By = {
  contractId?: Maybe<Order_By>;
  guarantorId?: Maybe<Order_By>;
  guatantyAmount?: Maybe<Order_By>;
  renterId?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type ContractsRentersRelation_Sum_Fields = {
  __typename?: 'contractsRentersRelation_sum_fields';
  contractId?: Maybe<Scalars['Int']>;
  guarantorId?: Maybe<Scalars['Int']>;
  guatantyAmount?: Maybe<Scalars['float8']>;
  renterId?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "contractsRentersRelation" */
export type ContractsRentersRelation_Sum_Order_By = {
  contractId?: Maybe<Order_By>;
  guarantorId?: Maybe<Order_By>;
  guatantyAmount?: Maybe<Order_By>;
  renterId?: Maybe<Order_By>;
};

/** update columns of table "contractsRentersRelation" */
export enum ContractsRentersRelation_Update_Column {
  /** column name */
  ContractId = 'contractId',
  /** column name */
  GuarantorId = 'guarantorId',
  /** column name */
  GuatantyAmount = 'guatantyAmount',
  /** column name */
  PropertySection = 'propertySection',
  /** column name */
  RenterId = 'renterId'
}

/** aggregate var_pop on columns */
export type ContractsRentersRelation_Var_Pop_Fields = {
  __typename?: 'contractsRentersRelation_var_pop_fields';
  contractId?: Maybe<Scalars['Float']>;
  guarantorId?: Maybe<Scalars['Float']>;
  guatantyAmount?: Maybe<Scalars['Float']>;
  renterId?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "contractsRentersRelation" */
export type ContractsRentersRelation_Var_Pop_Order_By = {
  contractId?: Maybe<Order_By>;
  guarantorId?: Maybe<Order_By>;
  guatantyAmount?: Maybe<Order_By>;
  renterId?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type ContractsRentersRelation_Var_Samp_Fields = {
  __typename?: 'contractsRentersRelation_var_samp_fields';
  contractId?: Maybe<Scalars['Float']>;
  guarantorId?: Maybe<Scalars['Float']>;
  guatantyAmount?: Maybe<Scalars['Float']>;
  renterId?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "contractsRentersRelation" */
export type ContractsRentersRelation_Var_Samp_Order_By = {
  contractId?: Maybe<Order_By>;
  guarantorId?: Maybe<Order_By>;
  guatantyAmount?: Maybe<Order_By>;
  renterId?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type ContractsRentersRelation_Variance_Fields = {
  __typename?: 'contractsRentersRelation_variance_fields';
  contractId?: Maybe<Scalars['Float']>;
  guarantorId?: Maybe<Scalars['Float']>;
  guatantyAmount?: Maybe<Scalars['Float']>;
  renterId?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "contractsRentersRelation" */
export type ContractsRentersRelation_Variance_Order_By = {
  contractId?: Maybe<Order_By>;
  guarantorId?: Maybe<Order_By>;
  guatantyAmount?: Maybe<Order_By>;
  renterId?: Maybe<Order_By>;
};

/** aggregated selection of "contracts" */
export type Contracts_Aggregate = {
  __typename?: 'contracts_aggregate';
  aggregate?: Maybe<Contracts_Aggregate_Fields>;
  nodes: Array<Contracts>;
};

/** aggregate fields of "contracts" */
export type Contracts_Aggregate_Fields = {
  __typename?: 'contracts_aggregate_fields';
  avg?: Maybe<Contracts_Avg_Fields>;
  count?: Maybe<Scalars['Int']>;
  max?: Maybe<Contracts_Max_Fields>;
  min?: Maybe<Contracts_Min_Fields>;
  stddev?: Maybe<Contracts_Stddev_Fields>;
  stddev_pop?: Maybe<Contracts_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Contracts_Stddev_Samp_Fields>;
  sum?: Maybe<Contracts_Sum_Fields>;
  var_pop?: Maybe<Contracts_Var_Pop_Fields>;
  var_samp?: Maybe<Contracts_Var_Samp_Fields>;
  variance?: Maybe<Contracts_Variance_Fields>;
};


/** aggregate fields of "contracts" */
export type Contracts_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Contracts_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "contracts" */
export type Contracts_Aggregate_Order_By = {
  avg?: Maybe<Contracts_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Contracts_Max_Order_By>;
  min?: Maybe<Contracts_Min_Order_By>;
  stddev?: Maybe<Contracts_Stddev_Order_By>;
  stddev_pop?: Maybe<Contracts_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Contracts_Stddev_Samp_Order_By>;
  sum?: Maybe<Contracts_Sum_Order_By>;
  var_pop?: Maybe<Contracts_Var_Pop_Order_By>;
  var_samp?: Maybe<Contracts_Var_Samp_Order_By>;
  variance?: Maybe<Contracts_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "contracts" */
export type Contracts_Arr_Rel_Insert_Input = {
  data: Array<Contracts_Insert_Input>;
  on_conflict?: Maybe<Contracts_On_Conflict>;
};

/** aggregate avg on columns */
export type Contracts_Avg_Fields = {
  __typename?: 'contracts_avg_fields';
  id?: Maybe<Scalars['Float']>;
  propertyId?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "contracts" */
export type Contracts_Avg_Order_By = {
  id?: Maybe<Order_By>;
  propertyId?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "contracts". All fields are combined with a logical 'AND'. */
export type Contracts_Bool_Exp = {
  _and?: Maybe<Array<Maybe<Contracts_Bool_Exp>>>;
  _not?: Maybe<Contracts_Bool_Exp>;
  _or?: Maybe<Array<Maybe<Contracts_Bool_Exp>>>;
  arnonaPayByRenters?: Maybe<Boolean_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  electricityPayByRenters?: Maybe<Boolean_Comparison_Exp>;
  endDate?: Maybe<Date_Comparison_Exp>;
  gasPayByRenters?: Maybe<Boolean_Comparison_Exp>;
  id?: Maybe<Int_Comparison_Exp>;
  internetPayByRenters?: Maybe<Boolean_Comparison_Exp>;
  linkToS3?: Maybe<String_Comparison_Exp>;
  payments?: Maybe<Payments_Bool_Exp>;
  property?: Maybe<Properties_Bool_Exp>;
  propertyId?: Maybe<Int_Comparison_Exp>;
  startDate?: Maybe<Date_Comparison_Exp>;
  tickets?: Maybe<Tickets_Bool_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  vaadPayByRenters?: Maybe<Boolean_Comparison_Exp>;
  waterPayByRenters?: Maybe<Boolean_Comparison_Exp>;
};

/** unique or primary key constraints on table "contracts" */
export enum Contracts_Constraint {
  /** unique or primary key constraint */
  ContractsPkey = 'contracts_pkey'
}

/** input type for incrementing integer column in table "contracts" */
export type Contracts_Inc_Input = {
  id?: Maybe<Scalars['Int']>;
  propertyId?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "contracts" */
export type Contracts_Insert_Input = {
  arnonaPayByRenters?: Maybe<Scalars['Boolean']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  electricityPayByRenters?: Maybe<Scalars['Boolean']>;
  endDate?: Maybe<Scalars['date']>;
  gasPayByRenters?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['Int']>;
  internetPayByRenters?: Maybe<Scalars['Boolean']>;
  linkToS3?: Maybe<Scalars['String']>;
  payments?: Maybe<Payments_Arr_Rel_Insert_Input>;
  property?: Maybe<Properties_Obj_Rel_Insert_Input>;
  propertyId?: Maybe<Scalars['Int']>;
  startDate?: Maybe<Scalars['date']>;
  tickets?: Maybe<Tickets_Arr_Rel_Insert_Input>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  vaadPayByRenters?: Maybe<Scalars['Boolean']>;
  waterPayByRenters?: Maybe<Scalars['Boolean']>;
};

/** aggregate max on columns */
export type Contracts_Max_Fields = {
  __typename?: 'contracts_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  endDate?: Maybe<Scalars['date']>;
  id?: Maybe<Scalars['Int']>;
  linkToS3?: Maybe<Scalars['String']>;
  propertyId?: Maybe<Scalars['Int']>;
  startDate?: Maybe<Scalars['date']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "contracts" */
export type Contracts_Max_Order_By = {
  created_at?: Maybe<Order_By>;
  endDate?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  linkToS3?: Maybe<Order_By>;
  propertyId?: Maybe<Order_By>;
  startDate?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Contracts_Min_Fields = {
  __typename?: 'contracts_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  endDate?: Maybe<Scalars['date']>;
  id?: Maybe<Scalars['Int']>;
  linkToS3?: Maybe<Scalars['String']>;
  propertyId?: Maybe<Scalars['Int']>;
  startDate?: Maybe<Scalars['date']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "contracts" */
export type Contracts_Min_Order_By = {
  created_at?: Maybe<Order_By>;
  endDate?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  linkToS3?: Maybe<Order_By>;
  propertyId?: Maybe<Order_By>;
  startDate?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "contracts" */
export type Contracts_Mutation_Response = {
  __typename?: 'contracts_mutation_response';
  /** number of affected rows by the mutation */
  affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  returning: Array<Contracts>;
};

/** input type for inserting object relation for remote table "contracts" */
export type Contracts_Obj_Rel_Insert_Input = {
  data: Contracts_Insert_Input;
  on_conflict?: Maybe<Contracts_On_Conflict>;
};

/** on conflict condition type for table "contracts" */
export type Contracts_On_Conflict = {
  constraint: Contracts_Constraint;
  update_columns: Array<Contracts_Update_Column>;
  where?: Maybe<Contracts_Bool_Exp>;
};

/** ordering options when selecting data from "contracts" */
export type Contracts_Order_By = {
  arnonaPayByRenters?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  electricityPayByRenters?: Maybe<Order_By>;
  endDate?: Maybe<Order_By>;
  gasPayByRenters?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  internetPayByRenters?: Maybe<Order_By>;
  linkToS3?: Maybe<Order_By>;
  payments_aggregate?: Maybe<Payments_Aggregate_Order_By>;
  property?: Maybe<Properties_Order_By>;
  propertyId?: Maybe<Order_By>;
  startDate?: Maybe<Order_By>;
  tickets_aggregate?: Maybe<Tickets_Aggregate_Order_By>;
  updated_at?: Maybe<Order_By>;
  vaadPayByRenters?: Maybe<Order_By>;
  waterPayByRenters?: Maybe<Order_By>;
};

/** primary key columns input for table: "contracts" */
export type Contracts_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** select columns of table "contracts" */
export enum Contracts_Select_Column {
  /** column name */
  ArnonaPayByRenters = 'arnonaPayByRenters',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  ElectricityPayByRenters = 'electricityPayByRenters',
  /** column name */
  EndDate = 'endDate',
  /** column name */
  GasPayByRenters = 'gasPayByRenters',
  /** column name */
  Id = 'id',
  /** column name */
  InternetPayByRenters = 'internetPayByRenters',
  /** column name */
  LinkToS3 = 'linkToS3',
  /** column name */
  PropertyId = 'propertyId',
  /** column name */
  StartDate = 'startDate',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  VaadPayByRenters = 'vaadPayByRenters',
  /** column name */
  WaterPayByRenters = 'waterPayByRenters'
}

/** input type for updating data in table "contracts" */
export type Contracts_Set_Input = {
  arnonaPayByRenters?: Maybe<Scalars['Boolean']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  electricityPayByRenters?: Maybe<Scalars['Boolean']>;
  endDate?: Maybe<Scalars['date']>;
  gasPayByRenters?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['Int']>;
  internetPayByRenters?: Maybe<Scalars['Boolean']>;
  linkToS3?: Maybe<Scalars['String']>;
  propertyId?: Maybe<Scalars['Int']>;
  startDate?: Maybe<Scalars['date']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  vaadPayByRenters?: Maybe<Scalars['Boolean']>;
  waterPayByRenters?: Maybe<Scalars['Boolean']>;
};

/** aggregate stddev on columns */
export type Contracts_Stddev_Fields = {
  __typename?: 'contracts_stddev_fields';
  id?: Maybe<Scalars['Float']>;
  propertyId?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "contracts" */
export type Contracts_Stddev_Order_By = {
  id?: Maybe<Order_By>;
  propertyId?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Contracts_Stddev_Pop_Fields = {
  __typename?: 'contracts_stddev_pop_fields';
  id?: Maybe<Scalars['Float']>;
  propertyId?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "contracts" */
export type Contracts_Stddev_Pop_Order_By = {
  id?: Maybe<Order_By>;
  propertyId?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Contracts_Stddev_Samp_Fields = {
  __typename?: 'contracts_stddev_samp_fields';
  id?: Maybe<Scalars['Float']>;
  propertyId?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "contracts" */
export type Contracts_Stddev_Samp_Order_By = {
  id?: Maybe<Order_By>;
  propertyId?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Contracts_Sum_Fields = {
  __typename?: 'contracts_sum_fields';
  id?: Maybe<Scalars['Int']>;
  propertyId?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "contracts" */
export type Contracts_Sum_Order_By = {
  id?: Maybe<Order_By>;
  propertyId?: Maybe<Order_By>;
};

/** update columns of table "contracts" */
export enum Contracts_Update_Column {
  /** column name */
  ArnonaPayByRenters = 'arnonaPayByRenters',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  ElectricityPayByRenters = 'electricityPayByRenters',
  /** column name */
  EndDate = 'endDate',
  /** column name */
  GasPayByRenters = 'gasPayByRenters',
  /** column name */
  Id = 'id',
  /** column name */
  InternetPayByRenters = 'internetPayByRenters',
  /** column name */
  LinkToS3 = 'linkToS3',
  /** column name */
  PropertyId = 'propertyId',
  /** column name */
  StartDate = 'startDate',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  VaadPayByRenters = 'vaadPayByRenters',
  /** column name */
  WaterPayByRenters = 'waterPayByRenters'
}

/** aggregate var_pop on columns */
export type Contracts_Var_Pop_Fields = {
  __typename?: 'contracts_var_pop_fields';
  id?: Maybe<Scalars['Float']>;
  propertyId?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "contracts" */
export type Contracts_Var_Pop_Order_By = {
  id?: Maybe<Order_By>;
  propertyId?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Contracts_Var_Samp_Fields = {
  __typename?: 'contracts_var_samp_fields';
  id?: Maybe<Scalars['Float']>;
  propertyId?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "contracts" */
export type Contracts_Var_Samp_Order_By = {
  id?: Maybe<Order_By>;
  propertyId?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Contracts_Variance_Fields = {
  __typename?: 'contracts_variance_fields';
  id?: Maybe<Scalars['Float']>;
  propertyId?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "contracts" */
export type Contracts_Variance_Order_By = {
  id?: Maybe<Order_By>;
  propertyId?: Maybe<Order_By>;
};


/** expression to compare columns of type date. All fields are combined with logical 'AND'. */
export type Date_Comparison_Exp = {
  _eq?: Maybe<Scalars['date']>;
  _gt?: Maybe<Scalars['date']>;
  _gte?: Maybe<Scalars['date']>;
  _in?: Maybe<Array<Scalars['date']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['date']>;
  _lte?: Maybe<Scalars['date']>;
  _neq?: Maybe<Scalars['date']>;
  _nin?: Maybe<Array<Scalars['date']>>;
};

/** columns and relationships of "entities" */
export type Entities = {
  __typename?: 'entities';
  /** An array relationship */
  contractsRentersRelationsByRenterId: Array<ContractsRentersRelation>;
  /** An aggregated array relationship */
  contractsRentersRelationsByRenterId_aggregate: ContractsRentersRelation_Aggregate;
  /** An array relationship */
  contracts_renters_relations: Array<ContractsRentersRelation>;
  /** An aggregated array relationship */
  contracts_renters_relations_aggregate: ContractsRentersRelation_Aggregate;
  email?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  idNumber: Scalars['String'];
  letterAddress?: Maybe<Scalars['String']>;
  linkToS3?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
};


/** columns and relationships of "entities" */
export type EntitiesContractsRentersRelationsByRenterIdArgs = {
  distinct_on?: Maybe<Array<ContractsRentersRelation_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<ContractsRentersRelation_Order_By>>;
  where?: Maybe<ContractsRentersRelation_Bool_Exp>;
};


/** columns and relationships of "entities" */
export type EntitiesContractsRentersRelationsByRenterId_AggregateArgs = {
  distinct_on?: Maybe<Array<ContractsRentersRelation_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<ContractsRentersRelation_Order_By>>;
  where?: Maybe<ContractsRentersRelation_Bool_Exp>;
};


/** columns and relationships of "entities" */
export type EntitiesContracts_Renters_RelationsArgs = {
  distinct_on?: Maybe<Array<ContractsRentersRelation_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<ContractsRentersRelation_Order_By>>;
  where?: Maybe<ContractsRentersRelation_Bool_Exp>;
};


/** columns and relationships of "entities" */
export type EntitiesContracts_Renters_Relations_AggregateArgs = {
  distinct_on?: Maybe<Array<ContractsRentersRelation_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<ContractsRentersRelation_Order_By>>;
  where?: Maybe<ContractsRentersRelation_Bool_Exp>;
};

/** aggregated selection of "entities" */
export type Entities_Aggregate = {
  __typename?: 'entities_aggregate';
  aggregate?: Maybe<Entities_Aggregate_Fields>;
  nodes: Array<Entities>;
};

/** aggregate fields of "entities" */
export type Entities_Aggregate_Fields = {
  __typename?: 'entities_aggregate_fields';
  avg?: Maybe<Entities_Avg_Fields>;
  count?: Maybe<Scalars['Int']>;
  max?: Maybe<Entities_Max_Fields>;
  min?: Maybe<Entities_Min_Fields>;
  stddev?: Maybe<Entities_Stddev_Fields>;
  stddev_pop?: Maybe<Entities_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Entities_Stddev_Samp_Fields>;
  sum?: Maybe<Entities_Sum_Fields>;
  var_pop?: Maybe<Entities_Var_Pop_Fields>;
  var_samp?: Maybe<Entities_Var_Samp_Fields>;
  variance?: Maybe<Entities_Variance_Fields>;
};


/** aggregate fields of "entities" */
export type Entities_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Entities_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "entities" */
export type Entities_Aggregate_Order_By = {
  avg?: Maybe<Entities_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Entities_Max_Order_By>;
  min?: Maybe<Entities_Min_Order_By>;
  stddev?: Maybe<Entities_Stddev_Order_By>;
  stddev_pop?: Maybe<Entities_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Entities_Stddev_Samp_Order_By>;
  sum?: Maybe<Entities_Sum_Order_By>;
  var_pop?: Maybe<Entities_Var_Pop_Order_By>;
  var_samp?: Maybe<Entities_Var_Samp_Order_By>;
  variance?: Maybe<Entities_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "entities" */
export type Entities_Arr_Rel_Insert_Input = {
  data: Array<Entities_Insert_Input>;
  on_conflict?: Maybe<Entities_On_Conflict>;
};

/** aggregate avg on columns */
export type Entities_Avg_Fields = {
  __typename?: 'entities_avg_fields';
  id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "entities" */
export type Entities_Avg_Order_By = {
  id?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "entities". All fields are combined with a logical 'AND'. */
export type Entities_Bool_Exp = {
  _and?: Maybe<Array<Maybe<Entities_Bool_Exp>>>;
  _not?: Maybe<Entities_Bool_Exp>;
  _or?: Maybe<Array<Maybe<Entities_Bool_Exp>>>;
  contractsRentersRelationsByRenterId?: Maybe<ContractsRentersRelation_Bool_Exp>;
  contracts_renters_relations?: Maybe<ContractsRentersRelation_Bool_Exp>;
  email?: Maybe<String_Comparison_Exp>;
  id?: Maybe<Int_Comparison_Exp>;
  idNumber?: Maybe<String_Comparison_Exp>;
  letterAddress?: Maybe<String_Comparison_Exp>;
  linkToS3?: Maybe<String_Comparison_Exp>;
  phone?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "entities" */
export enum Entities_Constraint {
  /** unique or primary key constraint */
  EntitiesPkey = 'entities_pkey'
}

/** input type for incrementing integer column in table "entities" */
export type Entities_Inc_Input = {
  id?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "entities" */
export type Entities_Insert_Input = {
  contractsRentersRelationsByRenterId?: Maybe<ContractsRentersRelation_Arr_Rel_Insert_Input>;
  contracts_renters_relations?: Maybe<ContractsRentersRelation_Arr_Rel_Insert_Input>;
  email?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  idNumber?: Maybe<Scalars['String']>;
  letterAddress?: Maybe<Scalars['String']>;
  linkToS3?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Entities_Max_Fields = {
  __typename?: 'entities_max_fields';
  email?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  idNumber?: Maybe<Scalars['String']>;
  letterAddress?: Maybe<Scalars['String']>;
  linkToS3?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "entities" */
export type Entities_Max_Order_By = {
  email?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  idNumber?: Maybe<Order_By>;
  letterAddress?: Maybe<Order_By>;
  linkToS3?: Maybe<Order_By>;
  phone?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Entities_Min_Fields = {
  __typename?: 'entities_min_fields';
  email?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  idNumber?: Maybe<Scalars['String']>;
  letterAddress?: Maybe<Scalars['String']>;
  linkToS3?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "entities" */
export type Entities_Min_Order_By = {
  email?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  idNumber?: Maybe<Order_By>;
  letterAddress?: Maybe<Order_By>;
  linkToS3?: Maybe<Order_By>;
  phone?: Maybe<Order_By>;
};

/** response of any mutation on the table "entities" */
export type Entities_Mutation_Response = {
  __typename?: 'entities_mutation_response';
  /** number of affected rows by the mutation */
  affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  returning: Array<Entities>;
};

/** input type for inserting object relation for remote table "entities" */
export type Entities_Obj_Rel_Insert_Input = {
  data: Entities_Insert_Input;
  on_conflict?: Maybe<Entities_On_Conflict>;
};

/** on conflict condition type for table "entities" */
export type Entities_On_Conflict = {
  constraint: Entities_Constraint;
  update_columns: Array<Entities_Update_Column>;
  where?: Maybe<Entities_Bool_Exp>;
};

/** ordering options when selecting data from "entities" */
export type Entities_Order_By = {
  contractsRentersRelationsByRenterId_aggregate?: Maybe<ContractsRentersRelation_Aggregate_Order_By>;
  contracts_renters_relations_aggregate?: Maybe<ContractsRentersRelation_Aggregate_Order_By>;
  email?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  idNumber?: Maybe<Order_By>;
  letterAddress?: Maybe<Order_By>;
  linkToS3?: Maybe<Order_By>;
  phone?: Maybe<Order_By>;
};

/** primary key columns input for table: "entities" */
export type Entities_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** select columns of table "entities" */
export enum Entities_Select_Column {
  /** column name */
  Email = 'email',
  /** column name */
  Id = 'id',
  /** column name */
  IdNumber = 'idNumber',
  /** column name */
  LetterAddress = 'letterAddress',
  /** column name */
  LinkToS3 = 'linkToS3',
  /** column name */
  Phone = 'phone'
}

/** input type for updating data in table "entities" */
export type Entities_Set_Input = {
  email?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  idNumber?: Maybe<Scalars['String']>;
  letterAddress?: Maybe<Scalars['String']>;
  linkToS3?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type Entities_Stddev_Fields = {
  __typename?: 'entities_stddev_fields';
  id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "entities" */
export type Entities_Stddev_Order_By = {
  id?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Entities_Stddev_Pop_Fields = {
  __typename?: 'entities_stddev_pop_fields';
  id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "entities" */
export type Entities_Stddev_Pop_Order_By = {
  id?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Entities_Stddev_Samp_Fields = {
  __typename?: 'entities_stddev_samp_fields';
  id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "entities" */
export type Entities_Stddev_Samp_Order_By = {
  id?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Entities_Sum_Fields = {
  __typename?: 'entities_sum_fields';
  id?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "entities" */
export type Entities_Sum_Order_By = {
  id?: Maybe<Order_By>;
};

/** update columns of table "entities" */
export enum Entities_Update_Column {
  /** column name */
  Email = 'email',
  /** column name */
  Id = 'id',
  /** column name */
  IdNumber = 'idNumber',
  /** column name */
  LetterAddress = 'letterAddress',
  /** column name */
  LinkToS3 = 'linkToS3',
  /** column name */
  Phone = 'phone'
}

/** aggregate var_pop on columns */
export type Entities_Var_Pop_Fields = {
  __typename?: 'entities_var_pop_fields';
  id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "entities" */
export type Entities_Var_Pop_Order_By = {
  id?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Entities_Var_Samp_Fields = {
  __typename?: 'entities_var_samp_fields';
  id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "entities" */
export type Entities_Var_Samp_Order_By = {
  id?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Entities_Variance_Fields = {
  __typename?: 'entities_variance_fields';
  id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "entities" */
export type Entities_Variance_Order_By = {
  id?: Maybe<Order_By>;
};


/** expression to compare columns of type float8. All fields are combined with logical 'AND'. */
export type Float8_Comparison_Exp = {
  _eq?: Maybe<Scalars['float8']>;
  _gt?: Maybe<Scalars['float8']>;
  _gte?: Maybe<Scalars['float8']>;
  _in?: Maybe<Array<Scalars['float8']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['float8']>;
  _lte?: Maybe<Scalars['float8']>;
  _neq?: Maybe<Scalars['float8']>;
  _nin?: Maybe<Array<Scalars['float8']>>;
};

/** columns and relationships of "insuranceContracts" */
export type InsuranceContracts = {
  __typename?: 'insuranceContracts';
  comment?: Maybe<Scalars['String']>;
  endDate?: Maybe<Scalars['date']>;
  id: Scalars['Int'];
  linkToS3?: Maybe<Scalars['String']>;
  price?: Maybe<Scalars['float8']>;
  /** An object relationship */
  property: Properties;
  propertyId: Scalars['Int'];
  startDate?: Maybe<Scalars['date']>;
  whoPay: Scalars['Int'];
};

/** aggregated selection of "insuranceContracts" */
export type InsuranceContracts_Aggregate = {
  __typename?: 'insuranceContracts_aggregate';
  aggregate?: Maybe<InsuranceContracts_Aggregate_Fields>;
  nodes: Array<InsuranceContracts>;
};

/** aggregate fields of "insuranceContracts" */
export type InsuranceContracts_Aggregate_Fields = {
  __typename?: 'insuranceContracts_aggregate_fields';
  avg?: Maybe<InsuranceContracts_Avg_Fields>;
  count?: Maybe<Scalars['Int']>;
  max?: Maybe<InsuranceContracts_Max_Fields>;
  min?: Maybe<InsuranceContracts_Min_Fields>;
  stddev?: Maybe<InsuranceContracts_Stddev_Fields>;
  stddev_pop?: Maybe<InsuranceContracts_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<InsuranceContracts_Stddev_Samp_Fields>;
  sum?: Maybe<InsuranceContracts_Sum_Fields>;
  var_pop?: Maybe<InsuranceContracts_Var_Pop_Fields>;
  var_samp?: Maybe<InsuranceContracts_Var_Samp_Fields>;
  variance?: Maybe<InsuranceContracts_Variance_Fields>;
};


/** aggregate fields of "insuranceContracts" */
export type InsuranceContracts_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<InsuranceContracts_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "insuranceContracts" */
export type InsuranceContracts_Aggregate_Order_By = {
  avg?: Maybe<InsuranceContracts_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<InsuranceContracts_Max_Order_By>;
  min?: Maybe<InsuranceContracts_Min_Order_By>;
  stddev?: Maybe<InsuranceContracts_Stddev_Order_By>;
  stddev_pop?: Maybe<InsuranceContracts_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<InsuranceContracts_Stddev_Samp_Order_By>;
  sum?: Maybe<InsuranceContracts_Sum_Order_By>;
  var_pop?: Maybe<InsuranceContracts_Var_Pop_Order_By>;
  var_samp?: Maybe<InsuranceContracts_Var_Samp_Order_By>;
  variance?: Maybe<InsuranceContracts_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "insuranceContracts" */
export type InsuranceContracts_Arr_Rel_Insert_Input = {
  data: Array<InsuranceContracts_Insert_Input>;
  on_conflict?: Maybe<InsuranceContracts_On_Conflict>;
};

/** aggregate avg on columns */
export type InsuranceContracts_Avg_Fields = {
  __typename?: 'insuranceContracts_avg_fields';
  id?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  propertyId?: Maybe<Scalars['Float']>;
  whoPay?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "insuranceContracts" */
export type InsuranceContracts_Avg_Order_By = {
  id?: Maybe<Order_By>;
  price?: Maybe<Order_By>;
  propertyId?: Maybe<Order_By>;
  whoPay?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "insuranceContracts". All fields are combined with a logical 'AND'. */
export type InsuranceContracts_Bool_Exp = {
  _and?: Maybe<Array<Maybe<InsuranceContracts_Bool_Exp>>>;
  _not?: Maybe<InsuranceContracts_Bool_Exp>;
  _or?: Maybe<Array<Maybe<InsuranceContracts_Bool_Exp>>>;
  comment?: Maybe<String_Comparison_Exp>;
  endDate?: Maybe<Date_Comparison_Exp>;
  id?: Maybe<Int_Comparison_Exp>;
  linkToS3?: Maybe<String_Comparison_Exp>;
  price?: Maybe<Float8_Comparison_Exp>;
  property?: Maybe<Properties_Bool_Exp>;
  propertyId?: Maybe<Int_Comparison_Exp>;
  startDate?: Maybe<Date_Comparison_Exp>;
  whoPay?: Maybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "insuranceContracts" */
export enum InsuranceContracts_Constraint {
  /** unique or primary key constraint */
  InsuranceContractsPkey = 'insurance_contracts_pkey'
}

/** input type for incrementing integer column in table "insuranceContracts" */
export type InsuranceContracts_Inc_Input = {
  id?: Maybe<Scalars['Int']>;
  price?: Maybe<Scalars['float8']>;
  propertyId?: Maybe<Scalars['Int']>;
  whoPay?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "insuranceContracts" */
export type InsuranceContracts_Insert_Input = {
  comment?: Maybe<Scalars['String']>;
  endDate?: Maybe<Scalars['date']>;
  id?: Maybe<Scalars['Int']>;
  linkToS3?: Maybe<Scalars['String']>;
  price?: Maybe<Scalars['float8']>;
  property?: Maybe<Properties_Obj_Rel_Insert_Input>;
  propertyId?: Maybe<Scalars['Int']>;
  startDate?: Maybe<Scalars['date']>;
  whoPay?: Maybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type InsuranceContracts_Max_Fields = {
  __typename?: 'insuranceContracts_max_fields';
  comment?: Maybe<Scalars['String']>;
  endDate?: Maybe<Scalars['date']>;
  id?: Maybe<Scalars['Int']>;
  linkToS3?: Maybe<Scalars['String']>;
  price?: Maybe<Scalars['float8']>;
  propertyId?: Maybe<Scalars['Int']>;
  startDate?: Maybe<Scalars['date']>;
  whoPay?: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "insuranceContracts" */
export type InsuranceContracts_Max_Order_By = {
  comment?: Maybe<Order_By>;
  endDate?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  linkToS3?: Maybe<Order_By>;
  price?: Maybe<Order_By>;
  propertyId?: Maybe<Order_By>;
  startDate?: Maybe<Order_By>;
  whoPay?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type InsuranceContracts_Min_Fields = {
  __typename?: 'insuranceContracts_min_fields';
  comment?: Maybe<Scalars['String']>;
  endDate?: Maybe<Scalars['date']>;
  id?: Maybe<Scalars['Int']>;
  linkToS3?: Maybe<Scalars['String']>;
  price?: Maybe<Scalars['float8']>;
  propertyId?: Maybe<Scalars['Int']>;
  startDate?: Maybe<Scalars['date']>;
  whoPay?: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "insuranceContracts" */
export type InsuranceContracts_Min_Order_By = {
  comment?: Maybe<Order_By>;
  endDate?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  linkToS3?: Maybe<Order_By>;
  price?: Maybe<Order_By>;
  propertyId?: Maybe<Order_By>;
  startDate?: Maybe<Order_By>;
  whoPay?: Maybe<Order_By>;
};

/** response of any mutation on the table "insuranceContracts" */
export type InsuranceContracts_Mutation_Response = {
  __typename?: 'insuranceContracts_mutation_response';
  /** number of affected rows by the mutation */
  affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  returning: Array<InsuranceContracts>;
};

/** input type for inserting object relation for remote table "insuranceContracts" */
export type InsuranceContracts_Obj_Rel_Insert_Input = {
  data: InsuranceContracts_Insert_Input;
  on_conflict?: Maybe<InsuranceContracts_On_Conflict>;
};

/** on conflict condition type for table "insuranceContracts" */
export type InsuranceContracts_On_Conflict = {
  constraint: InsuranceContracts_Constraint;
  update_columns: Array<InsuranceContracts_Update_Column>;
  where?: Maybe<InsuranceContracts_Bool_Exp>;
};

/** ordering options when selecting data from "insuranceContracts" */
export type InsuranceContracts_Order_By = {
  comment?: Maybe<Order_By>;
  endDate?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  linkToS3?: Maybe<Order_By>;
  price?: Maybe<Order_By>;
  property?: Maybe<Properties_Order_By>;
  propertyId?: Maybe<Order_By>;
  startDate?: Maybe<Order_By>;
  whoPay?: Maybe<Order_By>;
};

/** primary key columns input for table: "insuranceContracts" */
export type InsuranceContracts_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** select columns of table "insuranceContracts" */
export enum InsuranceContracts_Select_Column {
  /** column name */
  Comment = 'comment',
  /** column name */
  EndDate = 'endDate',
  /** column name */
  Id = 'id',
  /** column name */
  LinkToS3 = 'linkToS3',
  /** column name */
  Price = 'price',
  /** column name */
  PropertyId = 'propertyId',
  /** column name */
  StartDate = 'startDate',
  /** column name */
  WhoPay = 'whoPay'
}

/** input type for updating data in table "insuranceContracts" */
export type InsuranceContracts_Set_Input = {
  comment?: Maybe<Scalars['String']>;
  endDate?: Maybe<Scalars['date']>;
  id?: Maybe<Scalars['Int']>;
  linkToS3?: Maybe<Scalars['String']>;
  price?: Maybe<Scalars['float8']>;
  propertyId?: Maybe<Scalars['Int']>;
  startDate?: Maybe<Scalars['date']>;
  whoPay?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type InsuranceContracts_Stddev_Fields = {
  __typename?: 'insuranceContracts_stddev_fields';
  id?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  propertyId?: Maybe<Scalars['Float']>;
  whoPay?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "insuranceContracts" */
export type InsuranceContracts_Stddev_Order_By = {
  id?: Maybe<Order_By>;
  price?: Maybe<Order_By>;
  propertyId?: Maybe<Order_By>;
  whoPay?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type InsuranceContracts_Stddev_Pop_Fields = {
  __typename?: 'insuranceContracts_stddev_pop_fields';
  id?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  propertyId?: Maybe<Scalars['Float']>;
  whoPay?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "insuranceContracts" */
export type InsuranceContracts_Stddev_Pop_Order_By = {
  id?: Maybe<Order_By>;
  price?: Maybe<Order_By>;
  propertyId?: Maybe<Order_By>;
  whoPay?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type InsuranceContracts_Stddev_Samp_Fields = {
  __typename?: 'insuranceContracts_stddev_samp_fields';
  id?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  propertyId?: Maybe<Scalars['Float']>;
  whoPay?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "insuranceContracts" */
export type InsuranceContracts_Stddev_Samp_Order_By = {
  id?: Maybe<Order_By>;
  price?: Maybe<Order_By>;
  propertyId?: Maybe<Order_By>;
  whoPay?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type InsuranceContracts_Sum_Fields = {
  __typename?: 'insuranceContracts_sum_fields';
  id?: Maybe<Scalars['Int']>;
  price?: Maybe<Scalars['float8']>;
  propertyId?: Maybe<Scalars['Int']>;
  whoPay?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "insuranceContracts" */
export type InsuranceContracts_Sum_Order_By = {
  id?: Maybe<Order_By>;
  price?: Maybe<Order_By>;
  propertyId?: Maybe<Order_By>;
  whoPay?: Maybe<Order_By>;
};

/** update columns of table "insuranceContracts" */
export enum InsuranceContracts_Update_Column {
  /** column name */
  Comment = 'comment',
  /** column name */
  EndDate = 'endDate',
  /** column name */
  Id = 'id',
  /** column name */
  LinkToS3 = 'linkToS3',
  /** column name */
  Price = 'price',
  /** column name */
  PropertyId = 'propertyId',
  /** column name */
  StartDate = 'startDate',
  /** column name */
  WhoPay = 'whoPay'
}

/** aggregate var_pop on columns */
export type InsuranceContracts_Var_Pop_Fields = {
  __typename?: 'insuranceContracts_var_pop_fields';
  id?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  propertyId?: Maybe<Scalars['Float']>;
  whoPay?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "insuranceContracts" */
export type InsuranceContracts_Var_Pop_Order_By = {
  id?: Maybe<Order_By>;
  price?: Maybe<Order_By>;
  propertyId?: Maybe<Order_By>;
  whoPay?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type InsuranceContracts_Var_Samp_Fields = {
  __typename?: 'insuranceContracts_var_samp_fields';
  id?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  propertyId?: Maybe<Scalars['Float']>;
  whoPay?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "insuranceContracts" */
export type InsuranceContracts_Var_Samp_Order_By = {
  id?: Maybe<Order_By>;
  price?: Maybe<Order_By>;
  propertyId?: Maybe<Order_By>;
  whoPay?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type InsuranceContracts_Variance_Fields = {
  __typename?: 'insuranceContracts_variance_fields';
  id?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  propertyId?: Maybe<Scalars['Float']>;
  whoPay?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "insuranceContracts" */
export type InsuranceContracts_Variance_Order_By = {
  id?: Maybe<Order_By>;
  price?: Maybe<Order_By>;
  propertyId?: Maybe<Order_By>;
  whoPay?: Maybe<Order_By>;
};


/** expression to compare columns of type money. All fields are combined with logical 'AND'. */
export type Money_Comparison_Exp = {
  _eq?: Maybe<Scalars['money']>;
  _gt?: Maybe<Scalars['money']>;
  _gte?: Maybe<Scalars['money']>;
  _in?: Maybe<Array<Scalars['money']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['money']>;
  _lte?: Maybe<Scalars['money']>;
  _neq?: Maybe<Scalars['money']>;
  _nin?: Maybe<Array<Scalars['money']>>;
};

/** mutation root */
export type Mutation_Root = {
  __typename?: 'mutation_root';
  /** delete data from the table: "contracts" */
  delete_contracts?: Maybe<Contracts_Mutation_Response>;
  /** delete data from the table: "contractsRentersRelation" */
  delete_contractsRentersRelation?: Maybe<ContractsRentersRelation_Mutation_Response>;
  /** delete single row from the table: "contractsRentersRelation" */
  delete_contractsRentersRelation_by_pk?: Maybe<ContractsRentersRelation>;
  /** delete single row from the table: "contracts" */
  delete_contracts_by_pk?: Maybe<Contracts>;
  /** delete data from the table: "entities" */
  delete_entities?: Maybe<Entities_Mutation_Response>;
  /** delete single row from the table: "entities" */
  delete_entities_by_pk?: Maybe<Entities>;
  /** delete data from the table: "insuranceContracts" */
  delete_insuranceContracts?: Maybe<InsuranceContracts_Mutation_Response>;
  /** delete single row from the table: "insuranceContracts" */
  delete_insuranceContracts_by_pk?: Maybe<InsuranceContracts>;
  /** delete data from the table: "payMethods" */
  delete_payMethods?: Maybe<PayMethods_Mutation_Response>;
  /** delete single row from the table: "payMethods" */
  delete_payMethods_by_pk?: Maybe<PayMethods>;
  /** delete data from the table: "payments" */
  delete_payments?: Maybe<Payments_Mutation_Response>;
  /** delete single row from the table: "payments" */
  delete_payments_by_pk?: Maybe<Payments>;
  /** delete data from the table: "projectManagers" */
  delete_projectManagers?: Maybe<ProjectManagers_Mutation_Response>;
  /** delete single row from the table: "projectManagers" */
  delete_projectManagers_by_pk?: Maybe<ProjectManagers>;
  /** delete data from the table: "properties" */
  delete_properties?: Maybe<Properties_Mutation_Response>;
  /** delete single row from the table: "properties" */
  delete_properties_by_pk?: Maybe<Properties>;
  /** delete data from the table: "ticketTypes" */
  delete_ticketTypes?: Maybe<TicketTypes_Mutation_Response>;
  /** delete single row from the table: "ticketTypes" */
  delete_ticketTypes_by_pk?: Maybe<TicketTypes>;
  /** delete data from the table: "tickets" */
  delete_tickets?: Maybe<Tickets_Mutation_Response>;
  /** delete single row from the table: "tickets" */
  delete_tickets_by_pk?: Maybe<Tickets>;
  /** insert data into the table: "contracts" */
  insert_contracts?: Maybe<Contracts_Mutation_Response>;
  /** insert data into the table: "contractsRentersRelation" */
  insert_contractsRentersRelation?: Maybe<ContractsRentersRelation_Mutation_Response>;
  /** insert a single row into the table: "contractsRentersRelation" */
  insert_contractsRentersRelation_one?: Maybe<ContractsRentersRelation>;
  /** insert a single row into the table: "contracts" */
  insert_contracts_one?: Maybe<Contracts>;
  /** insert data into the table: "entities" */
  insert_entities?: Maybe<Entities_Mutation_Response>;
  /** insert a single row into the table: "entities" */
  insert_entities_one?: Maybe<Entities>;
  /** insert data into the table: "insuranceContracts" */
  insert_insuranceContracts?: Maybe<InsuranceContracts_Mutation_Response>;
  /** insert a single row into the table: "insuranceContracts" */
  insert_insuranceContracts_one?: Maybe<InsuranceContracts>;
  /** insert data into the table: "payMethods" */
  insert_payMethods?: Maybe<PayMethods_Mutation_Response>;
  /** insert a single row into the table: "payMethods" */
  insert_payMethods_one?: Maybe<PayMethods>;
  /** insert data into the table: "payments" */
  insert_payments?: Maybe<Payments_Mutation_Response>;
  /** insert a single row into the table: "payments" */
  insert_payments_one?: Maybe<Payments>;
  /** insert data into the table: "projectManagers" */
  insert_projectManagers?: Maybe<ProjectManagers_Mutation_Response>;
  /** insert a single row into the table: "projectManagers" */
  insert_projectManagers_one?: Maybe<ProjectManagers>;
  /** insert data into the table: "properties" */
  insert_properties?: Maybe<Properties_Mutation_Response>;
  /** insert a single row into the table: "properties" */
  insert_properties_one?: Maybe<Properties>;
  /** insert data into the table: "ticketTypes" */
  insert_ticketTypes?: Maybe<TicketTypes_Mutation_Response>;
  /** insert a single row into the table: "ticketTypes" */
  insert_ticketTypes_one?: Maybe<TicketTypes>;
  /** insert data into the table: "tickets" */
  insert_tickets?: Maybe<Tickets_Mutation_Response>;
  /** insert a single row into the table: "tickets" */
  insert_tickets_one?: Maybe<Tickets>;
  /** update data of the table: "contracts" */
  update_contracts?: Maybe<Contracts_Mutation_Response>;
  /** update data of the table: "contractsRentersRelation" */
  update_contractsRentersRelation?: Maybe<ContractsRentersRelation_Mutation_Response>;
  /** update single row of the table: "contractsRentersRelation" */
  update_contractsRentersRelation_by_pk?: Maybe<ContractsRentersRelation>;
  /** update single row of the table: "contracts" */
  update_contracts_by_pk?: Maybe<Contracts>;
  /** update data of the table: "entities" */
  update_entities?: Maybe<Entities_Mutation_Response>;
  /** update single row of the table: "entities" */
  update_entities_by_pk?: Maybe<Entities>;
  /** update data of the table: "insuranceContracts" */
  update_insuranceContracts?: Maybe<InsuranceContracts_Mutation_Response>;
  /** update single row of the table: "insuranceContracts" */
  update_insuranceContracts_by_pk?: Maybe<InsuranceContracts>;
  /** update data of the table: "payMethods" */
  update_payMethods?: Maybe<PayMethods_Mutation_Response>;
  /** update single row of the table: "payMethods" */
  update_payMethods_by_pk?: Maybe<PayMethods>;
  /** update data of the table: "payments" */
  update_payments?: Maybe<Payments_Mutation_Response>;
  /** update single row of the table: "payments" */
  update_payments_by_pk?: Maybe<Payments>;
  /** update data of the table: "projectManagers" */
  update_projectManagers?: Maybe<ProjectManagers_Mutation_Response>;
  /** update single row of the table: "projectManagers" */
  update_projectManagers_by_pk?: Maybe<ProjectManagers>;
  /** update data of the table: "properties" */
  update_properties?: Maybe<Properties_Mutation_Response>;
  /** update single row of the table: "properties" */
  update_properties_by_pk?: Maybe<Properties>;
  /** update data of the table: "ticketTypes" */
  update_ticketTypes?: Maybe<TicketTypes_Mutation_Response>;
  /** update single row of the table: "ticketTypes" */
  update_ticketTypes_by_pk?: Maybe<TicketTypes>;
  /** update data of the table: "tickets" */
  update_tickets?: Maybe<Tickets_Mutation_Response>;
  /** update single row of the table: "tickets" */
  update_tickets_by_pk?: Maybe<Tickets>;
};


/** mutation root */
export type Mutation_RootDelete_ContractsArgs = {
  where: Contracts_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_ContractsRentersRelationArgs = {
  where: ContractsRentersRelation_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_ContractsRentersRelation_By_PkArgs = {
  contractId: Scalars['Int'];
  renterId: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_Contracts_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_EntitiesArgs = {
  where: Entities_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Entities_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_InsuranceContractsArgs = {
  where: InsuranceContracts_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_InsuranceContracts_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_PayMethodsArgs = {
  where: PayMethods_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_PayMethods_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_PaymentsArgs = {
  where: Payments_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Payments_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_ProjectManagersArgs = {
  where: ProjectManagers_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_ProjectManagers_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_PropertiesArgs = {
  where: Properties_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Properties_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_TicketTypesArgs = {
  where: TicketTypes_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_TicketTypes_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_TicketsArgs = {
  where: Tickets_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Tickets_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootInsert_ContractsArgs = {
  objects: Array<Contracts_Insert_Input>;
  on_conflict?: Maybe<Contracts_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ContractsRentersRelationArgs = {
  objects: Array<ContractsRentersRelation_Insert_Input>;
  on_conflict?: Maybe<ContractsRentersRelation_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ContractsRentersRelation_OneArgs = {
  object: ContractsRentersRelation_Insert_Input;
  on_conflict?: Maybe<ContractsRentersRelation_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Contracts_OneArgs = {
  object: Contracts_Insert_Input;
  on_conflict?: Maybe<Contracts_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_EntitiesArgs = {
  objects: Array<Entities_Insert_Input>;
  on_conflict?: Maybe<Entities_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Entities_OneArgs = {
  object: Entities_Insert_Input;
  on_conflict?: Maybe<Entities_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_InsuranceContractsArgs = {
  objects: Array<InsuranceContracts_Insert_Input>;
  on_conflict?: Maybe<InsuranceContracts_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_InsuranceContracts_OneArgs = {
  object: InsuranceContracts_Insert_Input;
  on_conflict?: Maybe<InsuranceContracts_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_PayMethodsArgs = {
  objects: Array<PayMethods_Insert_Input>;
  on_conflict?: Maybe<PayMethods_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_PayMethods_OneArgs = {
  object: PayMethods_Insert_Input;
  on_conflict?: Maybe<PayMethods_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_PaymentsArgs = {
  objects: Array<Payments_Insert_Input>;
  on_conflict?: Maybe<Payments_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Payments_OneArgs = {
  object: Payments_Insert_Input;
  on_conflict?: Maybe<Payments_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ProjectManagersArgs = {
  objects: Array<ProjectManagers_Insert_Input>;
  on_conflict?: Maybe<ProjectManagers_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ProjectManagers_OneArgs = {
  object: ProjectManagers_Insert_Input;
  on_conflict?: Maybe<ProjectManagers_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_PropertiesArgs = {
  objects: Array<Properties_Insert_Input>;
  on_conflict?: Maybe<Properties_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Properties_OneArgs = {
  object: Properties_Insert_Input;
  on_conflict?: Maybe<Properties_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_TicketTypesArgs = {
  objects: Array<TicketTypes_Insert_Input>;
  on_conflict?: Maybe<TicketTypes_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_TicketTypes_OneArgs = {
  object: TicketTypes_Insert_Input;
  on_conflict?: Maybe<TicketTypes_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_TicketsArgs = {
  objects: Array<Tickets_Insert_Input>;
  on_conflict?: Maybe<Tickets_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Tickets_OneArgs = {
  object: Tickets_Insert_Input;
  on_conflict?: Maybe<Tickets_On_Conflict>;
};


/** mutation root */
export type Mutation_RootUpdate_ContractsArgs = {
  _inc?: Maybe<Contracts_Inc_Input>;
  _set?: Maybe<Contracts_Set_Input>;
  where: Contracts_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_ContractsRentersRelationArgs = {
  _inc?: Maybe<ContractsRentersRelation_Inc_Input>;
  _set?: Maybe<ContractsRentersRelation_Set_Input>;
  where: ContractsRentersRelation_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_ContractsRentersRelation_By_PkArgs = {
  _inc?: Maybe<ContractsRentersRelation_Inc_Input>;
  _set?: Maybe<ContractsRentersRelation_Set_Input>;
  pk_columns: ContractsRentersRelation_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Contracts_By_PkArgs = {
  _inc?: Maybe<Contracts_Inc_Input>;
  _set?: Maybe<Contracts_Set_Input>;
  pk_columns: Contracts_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_EntitiesArgs = {
  _inc?: Maybe<Entities_Inc_Input>;
  _set?: Maybe<Entities_Set_Input>;
  where: Entities_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Entities_By_PkArgs = {
  _inc?: Maybe<Entities_Inc_Input>;
  _set?: Maybe<Entities_Set_Input>;
  pk_columns: Entities_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_InsuranceContractsArgs = {
  _inc?: Maybe<InsuranceContracts_Inc_Input>;
  _set?: Maybe<InsuranceContracts_Set_Input>;
  where: InsuranceContracts_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_InsuranceContracts_By_PkArgs = {
  _inc?: Maybe<InsuranceContracts_Inc_Input>;
  _set?: Maybe<InsuranceContracts_Set_Input>;
  pk_columns: InsuranceContracts_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_PayMethodsArgs = {
  _inc?: Maybe<PayMethods_Inc_Input>;
  _set?: Maybe<PayMethods_Set_Input>;
  where: PayMethods_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_PayMethods_By_PkArgs = {
  _inc?: Maybe<PayMethods_Inc_Input>;
  _set?: Maybe<PayMethods_Set_Input>;
  pk_columns: PayMethods_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_PaymentsArgs = {
  _inc?: Maybe<Payments_Inc_Input>;
  _set?: Maybe<Payments_Set_Input>;
  where: Payments_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Payments_By_PkArgs = {
  _inc?: Maybe<Payments_Inc_Input>;
  _set?: Maybe<Payments_Set_Input>;
  pk_columns: Payments_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_ProjectManagersArgs = {
  _inc?: Maybe<ProjectManagers_Inc_Input>;
  _set?: Maybe<ProjectManagers_Set_Input>;
  where: ProjectManagers_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_ProjectManagers_By_PkArgs = {
  _inc?: Maybe<ProjectManagers_Inc_Input>;
  _set?: Maybe<ProjectManagers_Set_Input>;
  pk_columns: ProjectManagers_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_PropertiesArgs = {
  _inc?: Maybe<Properties_Inc_Input>;
  _set?: Maybe<Properties_Set_Input>;
  where: Properties_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Properties_By_PkArgs = {
  _inc?: Maybe<Properties_Inc_Input>;
  _set?: Maybe<Properties_Set_Input>;
  pk_columns: Properties_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_TicketTypesArgs = {
  _inc?: Maybe<TicketTypes_Inc_Input>;
  _set?: Maybe<TicketTypes_Set_Input>;
  where: TicketTypes_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_TicketTypes_By_PkArgs = {
  _inc?: Maybe<TicketTypes_Inc_Input>;
  _set?: Maybe<TicketTypes_Set_Input>;
  pk_columns: TicketTypes_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_TicketsArgs = {
  _inc?: Maybe<Tickets_Inc_Input>;
  _set?: Maybe<Tickets_Set_Input>;
  where: Tickets_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Tickets_By_PkArgs = {
  _inc?: Maybe<Tickets_Inc_Input>;
  _set?: Maybe<Tickets_Set_Input>;
  pk_columns: Tickets_Pk_Columns_Input;
};

/** column ordering options */
export enum Order_By {
  /** in the ascending order, nulls last */
  Asc = 'asc',
  /** in the ascending order, nulls first */
  AscNullsFirst = 'asc_nulls_first',
  /** in the ascending order, nulls last */
  AscNullsLast = 'asc_nulls_last',
  /** in the descending order, nulls first */
  Desc = 'desc',
  /** in the descending order, nulls first */
  DescNullsFirst = 'desc_nulls_first',
  /** in the descending order, nulls last */
  DescNullsLast = 'desc_nulls_last'
}

/** columns and relationships of "payMethods" */
export type PayMethods = {
  __typename?: 'payMethods';
  id: Scalars['Int'];
  methodType: Scalars['String'];
};

/** aggregated selection of "payMethods" */
export type PayMethods_Aggregate = {
  __typename?: 'payMethods_aggregate';
  aggregate?: Maybe<PayMethods_Aggregate_Fields>;
  nodes: Array<PayMethods>;
};

/** aggregate fields of "payMethods" */
export type PayMethods_Aggregate_Fields = {
  __typename?: 'payMethods_aggregate_fields';
  avg?: Maybe<PayMethods_Avg_Fields>;
  count?: Maybe<Scalars['Int']>;
  max?: Maybe<PayMethods_Max_Fields>;
  min?: Maybe<PayMethods_Min_Fields>;
  stddev?: Maybe<PayMethods_Stddev_Fields>;
  stddev_pop?: Maybe<PayMethods_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<PayMethods_Stddev_Samp_Fields>;
  sum?: Maybe<PayMethods_Sum_Fields>;
  var_pop?: Maybe<PayMethods_Var_Pop_Fields>;
  var_samp?: Maybe<PayMethods_Var_Samp_Fields>;
  variance?: Maybe<PayMethods_Variance_Fields>;
};


/** aggregate fields of "payMethods" */
export type PayMethods_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<PayMethods_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "payMethods" */
export type PayMethods_Aggregate_Order_By = {
  avg?: Maybe<PayMethods_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<PayMethods_Max_Order_By>;
  min?: Maybe<PayMethods_Min_Order_By>;
  stddev?: Maybe<PayMethods_Stddev_Order_By>;
  stddev_pop?: Maybe<PayMethods_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<PayMethods_Stddev_Samp_Order_By>;
  sum?: Maybe<PayMethods_Sum_Order_By>;
  var_pop?: Maybe<PayMethods_Var_Pop_Order_By>;
  var_samp?: Maybe<PayMethods_Var_Samp_Order_By>;
  variance?: Maybe<PayMethods_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "payMethods" */
export type PayMethods_Arr_Rel_Insert_Input = {
  data: Array<PayMethods_Insert_Input>;
  on_conflict?: Maybe<PayMethods_On_Conflict>;
};

/** aggregate avg on columns */
export type PayMethods_Avg_Fields = {
  __typename?: 'payMethods_avg_fields';
  id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "payMethods" */
export type PayMethods_Avg_Order_By = {
  id?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "payMethods". All fields are combined with a logical 'AND'. */
export type PayMethods_Bool_Exp = {
  _and?: Maybe<Array<Maybe<PayMethods_Bool_Exp>>>;
  _not?: Maybe<PayMethods_Bool_Exp>;
  _or?: Maybe<Array<Maybe<PayMethods_Bool_Exp>>>;
  id?: Maybe<Int_Comparison_Exp>;
  methodType?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "payMethods" */
export enum PayMethods_Constraint {
  /** unique or primary key constraint */
  PayMethodsPkey = 'pay_methods_pkey'
}

/** input type for incrementing integer column in table "payMethods" */
export type PayMethods_Inc_Input = {
  id?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "payMethods" */
export type PayMethods_Insert_Input = {
  id?: Maybe<Scalars['Int']>;
  methodType?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type PayMethods_Max_Fields = {
  __typename?: 'payMethods_max_fields';
  id?: Maybe<Scalars['Int']>;
  methodType?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "payMethods" */
export type PayMethods_Max_Order_By = {
  id?: Maybe<Order_By>;
  methodType?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type PayMethods_Min_Fields = {
  __typename?: 'payMethods_min_fields';
  id?: Maybe<Scalars['Int']>;
  methodType?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "payMethods" */
export type PayMethods_Min_Order_By = {
  id?: Maybe<Order_By>;
  methodType?: Maybe<Order_By>;
};

/** response of any mutation on the table "payMethods" */
export type PayMethods_Mutation_Response = {
  __typename?: 'payMethods_mutation_response';
  /** number of affected rows by the mutation */
  affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  returning: Array<PayMethods>;
};

/** input type for inserting object relation for remote table "payMethods" */
export type PayMethods_Obj_Rel_Insert_Input = {
  data: PayMethods_Insert_Input;
  on_conflict?: Maybe<PayMethods_On_Conflict>;
};

/** on conflict condition type for table "payMethods" */
export type PayMethods_On_Conflict = {
  constraint: PayMethods_Constraint;
  update_columns: Array<PayMethods_Update_Column>;
  where?: Maybe<PayMethods_Bool_Exp>;
};

/** ordering options when selecting data from "payMethods" */
export type PayMethods_Order_By = {
  id?: Maybe<Order_By>;
  methodType?: Maybe<Order_By>;
};

/** primary key columns input for table: "payMethods" */
export type PayMethods_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** select columns of table "payMethods" */
export enum PayMethods_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  MethodType = 'methodType'
}

/** input type for updating data in table "payMethods" */
export type PayMethods_Set_Input = {
  id?: Maybe<Scalars['Int']>;
  methodType?: Maybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type PayMethods_Stddev_Fields = {
  __typename?: 'payMethods_stddev_fields';
  id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "payMethods" */
export type PayMethods_Stddev_Order_By = {
  id?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type PayMethods_Stddev_Pop_Fields = {
  __typename?: 'payMethods_stddev_pop_fields';
  id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "payMethods" */
export type PayMethods_Stddev_Pop_Order_By = {
  id?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type PayMethods_Stddev_Samp_Fields = {
  __typename?: 'payMethods_stddev_samp_fields';
  id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "payMethods" */
export type PayMethods_Stddev_Samp_Order_By = {
  id?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type PayMethods_Sum_Fields = {
  __typename?: 'payMethods_sum_fields';
  id?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "payMethods" */
export type PayMethods_Sum_Order_By = {
  id?: Maybe<Order_By>;
};

/** update columns of table "payMethods" */
export enum PayMethods_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  MethodType = 'methodType'
}

/** aggregate var_pop on columns */
export type PayMethods_Var_Pop_Fields = {
  __typename?: 'payMethods_var_pop_fields';
  id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "payMethods" */
export type PayMethods_Var_Pop_Order_By = {
  id?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type PayMethods_Var_Samp_Fields = {
  __typename?: 'payMethods_var_samp_fields';
  id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "payMethods" */
export type PayMethods_Var_Samp_Order_By = {
  id?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type PayMethods_Variance_Fields = {
  __typename?: 'payMethods_variance_fields';
  id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "payMethods" */
export type PayMethods_Variance_Order_By = {
  id?: Maybe<Order_By>;
};

/** columns and relationships of "payments" */
export type Payments = {
  __typename?: 'payments';
  amount: Scalars['float8'];
  /** An object relationship */
  contract: Contracts;
  contractId: Scalars['Int'];
  date: Scalars['date'];
  id: Scalars['Int'];
  /** An array relationship */
  tickets: Array<Tickets>;
  /** An aggregated array relationship */
  tickets_aggregate: Tickets_Aggregate;
};


/** columns and relationships of "payments" */
export type PaymentsTicketsArgs = {
  distinct_on?: Maybe<Array<Tickets_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tickets_Order_By>>;
  where?: Maybe<Tickets_Bool_Exp>;
};


/** columns and relationships of "payments" */
export type PaymentsTickets_AggregateArgs = {
  distinct_on?: Maybe<Array<Tickets_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tickets_Order_By>>;
  where?: Maybe<Tickets_Bool_Exp>;
};

/** aggregated selection of "payments" */
export type Payments_Aggregate = {
  __typename?: 'payments_aggregate';
  aggregate?: Maybe<Payments_Aggregate_Fields>;
  nodes: Array<Payments>;
};

/** aggregate fields of "payments" */
export type Payments_Aggregate_Fields = {
  __typename?: 'payments_aggregate_fields';
  avg?: Maybe<Payments_Avg_Fields>;
  count?: Maybe<Scalars['Int']>;
  max?: Maybe<Payments_Max_Fields>;
  min?: Maybe<Payments_Min_Fields>;
  stddev?: Maybe<Payments_Stddev_Fields>;
  stddev_pop?: Maybe<Payments_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Payments_Stddev_Samp_Fields>;
  sum?: Maybe<Payments_Sum_Fields>;
  var_pop?: Maybe<Payments_Var_Pop_Fields>;
  var_samp?: Maybe<Payments_Var_Samp_Fields>;
  variance?: Maybe<Payments_Variance_Fields>;
};


/** aggregate fields of "payments" */
export type Payments_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Payments_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "payments" */
export type Payments_Aggregate_Order_By = {
  avg?: Maybe<Payments_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Payments_Max_Order_By>;
  min?: Maybe<Payments_Min_Order_By>;
  stddev?: Maybe<Payments_Stddev_Order_By>;
  stddev_pop?: Maybe<Payments_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Payments_Stddev_Samp_Order_By>;
  sum?: Maybe<Payments_Sum_Order_By>;
  var_pop?: Maybe<Payments_Var_Pop_Order_By>;
  var_samp?: Maybe<Payments_Var_Samp_Order_By>;
  variance?: Maybe<Payments_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "payments" */
export type Payments_Arr_Rel_Insert_Input = {
  data: Array<Payments_Insert_Input>;
  on_conflict?: Maybe<Payments_On_Conflict>;
};

/** aggregate avg on columns */
export type Payments_Avg_Fields = {
  __typename?: 'payments_avg_fields';
  amount?: Maybe<Scalars['Float']>;
  contractId?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "payments" */
export type Payments_Avg_Order_By = {
  amount?: Maybe<Order_By>;
  contractId?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "payments". All fields are combined with a logical 'AND'. */
export type Payments_Bool_Exp = {
  _and?: Maybe<Array<Maybe<Payments_Bool_Exp>>>;
  _not?: Maybe<Payments_Bool_Exp>;
  _or?: Maybe<Array<Maybe<Payments_Bool_Exp>>>;
  amount?: Maybe<Float8_Comparison_Exp>;
  contract?: Maybe<Contracts_Bool_Exp>;
  contractId?: Maybe<Int_Comparison_Exp>;
  date?: Maybe<Date_Comparison_Exp>;
  id?: Maybe<Int_Comparison_Exp>;
  tickets?: Maybe<Tickets_Bool_Exp>;
};

/** unique or primary key constraints on table "payments" */
export enum Payments_Constraint {
  /** unique or primary key constraint */
  PaymentsPkey = 'payments_pkey'
}

/** input type for incrementing integer column in table "payments" */
export type Payments_Inc_Input = {
  amount?: Maybe<Scalars['float8']>;
  contractId?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "payments" */
export type Payments_Insert_Input = {
  amount?: Maybe<Scalars['float8']>;
  contract?: Maybe<Contracts_Obj_Rel_Insert_Input>;
  contractId?: Maybe<Scalars['Int']>;
  date?: Maybe<Scalars['date']>;
  id?: Maybe<Scalars['Int']>;
  tickets?: Maybe<Tickets_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Payments_Max_Fields = {
  __typename?: 'payments_max_fields';
  amount?: Maybe<Scalars['float8']>;
  contractId?: Maybe<Scalars['Int']>;
  date?: Maybe<Scalars['date']>;
  id?: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "payments" */
export type Payments_Max_Order_By = {
  amount?: Maybe<Order_By>;
  contractId?: Maybe<Order_By>;
  date?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Payments_Min_Fields = {
  __typename?: 'payments_min_fields';
  amount?: Maybe<Scalars['float8']>;
  contractId?: Maybe<Scalars['Int']>;
  date?: Maybe<Scalars['date']>;
  id?: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "payments" */
export type Payments_Min_Order_By = {
  amount?: Maybe<Order_By>;
  contractId?: Maybe<Order_By>;
  date?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
};

/** response of any mutation on the table "payments" */
export type Payments_Mutation_Response = {
  __typename?: 'payments_mutation_response';
  /** number of affected rows by the mutation */
  affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  returning: Array<Payments>;
};

/** input type for inserting object relation for remote table "payments" */
export type Payments_Obj_Rel_Insert_Input = {
  data: Payments_Insert_Input;
  on_conflict?: Maybe<Payments_On_Conflict>;
};

/** on conflict condition type for table "payments" */
export type Payments_On_Conflict = {
  constraint: Payments_Constraint;
  update_columns: Array<Payments_Update_Column>;
  where?: Maybe<Payments_Bool_Exp>;
};

/** ordering options when selecting data from "payments" */
export type Payments_Order_By = {
  amount?: Maybe<Order_By>;
  contract?: Maybe<Contracts_Order_By>;
  contractId?: Maybe<Order_By>;
  date?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  tickets_aggregate?: Maybe<Tickets_Aggregate_Order_By>;
};

/** primary key columns input for table: "payments" */
export type Payments_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** select columns of table "payments" */
export enum Payments_Select_Column {
  /** column name */
  Amount = 'amount',
  /** column name */
  ContractId = 'contractId',
  /** column name */
  Date = 'date',
  /** column name */
  Id = 'id'
}

/** input type for updating data in table "payments" */
export type Payments_Set_Input = {
  amount?: Maybe<Scalars['float8']>;
  contractId?: Maybe<Scalars['Int']>;
  date?: Maybe<Scalars['date']>;
  id?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Payments_Stddev_Fields = {
  __typename?: 'payments_stddev_fields';
  amount?: Maybe<Scalars['Float']>;
  contractId?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "payments" */
export type Payments_Stddev_Order_By = {
  amount?: Maybe<Order_By>;
  contractId?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Payments_Stddev_Pop_Fields = {
  __typename?: 'payments_stddev_pop_fields';
  amount?: Maybe<Scalars['Float']>;
  contractId?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "payments" */
export type Payments_Stddev_Pop_Order_By = {
  amount?: Maybe<Order_By>;
  contractId?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Payments_Stddev_Samp_Fields = {
  __typename?: 'payments_stddev_samp_fields';
  amount?: Maybe<Scalars['Float']>;
  contractId?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "payments" */
export type Payments_Stddev_Samp_Order_By = {
  amount?: Maybe<Order_By>;
  contractId?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Payments_Sum_Fields = {
  __typename?: 'payments_sum_fields';
  amount?: Maybe<Scalars['float8']>;
  contractId?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "payments" */
export type Payments_Sum_Order_By = {
  amount?: Maybe<Order_By>;
  contractId?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
};

/** update columns of table "payments" */
export enum Payments_Update_Column {
  /** column name */
  Amount = 'amount',
  /** column name */
  ContractId = 'contractId',
  /** column name */
  Date = 'date',
  /** column name */
  Id = 'id'
}

/** aggregate var_pop on columns */
export type Payments_Var_Pop_Fields = {
  __typename?: 'payments_var_pop_fields';
  amount?: Maybe<Scalars['Float']>;
  contractId?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "payments" */
export type Payments_Var_Pop_Order_By = {
  amount?: Maybe<Order_By>;
  contractId?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Payments_Var_Samp_Fields = {
  __typename?: 'payments_var_samp_fields';
  amount?: Maybe<Scalars['Float']>;
  contractId?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "payments" */
export type Payments_Var_Samp_Order_By = {
  amount?: Maybe<Order_By>;
  contractId?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Payments_Variance_Fields = {
  __typename?: 'payments_variance_fields';
  amount?: Maybe<Scalars['Float']>;
  contractId?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "payments" */
export type Payments_Variance_Order_By = {
  amount?: Maybe<Order_By>;
  contractId?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
};

/** columns and relationships of "projectManagers" */
export type ProjectManagers = {
  __typename?: 'projectManagers';
  id: Scalars['Int'];
  name: Scalars['String'];
  /** An array relationship */
  properties: Array<Properties>;
  /** An aggregated array relationship */
  properties_aggregate: Properties_Aggregate;
  /** An array relationship */
  tickets: Array<Tickets>;
  /** An aggregated array relationship */
  tickets_aggregate: Tickets_Aggregate;
};


/** columns and relationships of "projectManagers" */
export type ProjectManagersPropertiesArgs = {
  distinct_on?: Maybe<Array<Properties_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Properties_Order_By>>;
  where?: Maybe<Properties_Bool_Exp>;
};


/** columns and relationships of "projectManagers" */
export type ProjectManagersProperties_AggregateArgs = {
  distinct_on?: Maybe<Array<Properties_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Properties_Order_By>>;
  where?: Maybe<Properties_Bool_Exp>;
};


/** columns and relationships of "projectManagers" */
export type ProjectManagersTicketsArgs = {
  distinct_on?: Maybe<Array<Tickets_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tickets_Order_By>>;
  where?: Maybe<Tickets_Bool_Exp>;
};


/** columns and relationships of "projectManagers" */
export type ProjectManagersTickets_AggregateArgs = {
  distinct_on?: Maybe<Array<Tickets_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tickets_Order_By>>;
  where?: Maybe<Tickets_Bool_Exp>;
};

/** aggregated selection of "projectManagers" */
export type ProjectManagers_Aggregate = {
  __typename?: 'projectManagers_aggregate';
  aggregate?: Maybe<ProjectManagers_Aggregate_Fields>;
  nodes: Array<ProjectManagers>;
};

/** aggregate fields of "projectManagers" */
export type ProjectManagers_Aggregate_Fields = {
  __typename?: 'projectManagers_aggregate_fields';
  avg?: Maybe<ProjectManagers_Avg_Fields>;
  count?: Maybe<Scalars['Int']>;
  max?: Maybe<ProjectManagers_Max_Fields>;
  min?: Maybe<ProjectManagers_Min_Fields>;
  stddev?: Maybe<ProjectManagers_Stddev_Fields>;
  stddev_pop?: Maybe<ProjectManagers_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<ProjectManagers_Stddev_Samp_Fields>;
  sum?: Maybe<ProjectManagers_Sum_Fields>;
  var_pop?: Maybe<ProjectManagers_Var_Pop_Fields>;
  var_samp?: Maybe<ProjectManagers_Var_Samp_Fields>;
  variance?: Maybe<ProjectManagers_Variance_Fields>;
};


/** aggregate fields of "projectManagers" */
export type ProjectManagers_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<ProjectManagers_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "projectManagers" */
export type ProjectManagers_Aggregate_Order_By = {
  avg?: Maybe<ProjectManagers_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<ProjectManagers_Max_Order_By>;
  min?: Maybe<ProjectManagers_Min_Order_By>;
  stddev?: Maybe<ProjectManagers_Stddev_Order_By>;
  stddev_pop?: Maybe<ProjectManagers_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<ProjectManagers_Stddev_Samp_Order_By>;
  sum?: Maybe<ProjectManagers_Sum_Order_By>;
  var_pop?: Maybe<ProjectManagers_Var_Pop_Order_By>;
  var_samp?: Maybe<ProjectManagers_Var_Samp_Order_By>;
  variance?: Maybe<ProjectManagers_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "projectManagers" */
export type ProjectManagers_Arr_Rel_Insert_Input = {
  data: Array<ProjectManagers_Insert_Input>;
  on_conflict?: Maybe<ProjectManagers_On_Conflict>;
};

/** aggregate avg on columns */
export type ProjectManagers_Avg_Fields = {
  __typename?: 'projectManagers_avg_fields';
  id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "projectManagers" */
export type ProjectManagers_Avg_Order_By = {
  id?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "projectManagers". All fields are combined with a logical 'AND'. */
export type ProjectManagers_Bool_Exp = {
  _and?: Maybe<Array<Maybe<ProjectManagers_Bool_Exp>>>;
  _not?: Maybe<ProjectManagers_Bool_Exp>;
  _or?: Maybe<Array<Maybe<ProjectManagers_Bool_Exp>>>;
  id?: Maybe<Int_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  properties?: Maybe<Properties_Bool_Exp>;
  tickets?: Maybe<Tickets_Bool_Exp>;
};

/** unique or primary key constraints on table "projectManagers" */
export enum ProjectManagers_Constraint {
  /** unique or primary key constraint */
  ProjectManagersPkey = 'project_managers_pkey'
}

/** input type for incrementing integer column in table "projectManagers" */
export type ProjectManagers_Inc_Input = {
  id?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "projectManagers" */
export type ProjectManagers_Insert_Input = {
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  properties?: Maybe<Properties_Arr_Rel_Insert_Input>;
  tickets?: Maybe<Tickets_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type ProjectManagers_Max_Fields = {
  __typename?: 'projectManagers_max_fields';
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "projectManagers" */
export type ProjectManagers_Max_Order_By = {
  id?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type ProjectManagers_Min_Fields = {
  __typename?: 'projectManagers_min_fields';
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "projectManagers" */
export type ProjectManagers_Min_Order_By = {
  id?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
};

/** response of any mutation on the table "projectManagers" */
export type ProjectManagers_Mutation_Response = {
  __typename?: 'projectManagers_mutation_response';
  /** number of affected rows by the mutation */
  affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  returning: Array<ProjectManagers>;
};

/** input type for inserting object relation for remote table "projectManagers" */
export type ProjectManagers_Obj_Rel_Insert_Input = {
  data: ProjectManagers_Insert_Input;
  on_conflict?: Maybe<ProjectManagers_On_Conflict>;
};

/** on conflict condition type for table "projectManagers" */
export type ProjectManagers_On_Conflict = {
  constraint: ProjectManagers_Constraint;
  update_columns: Array<ProjectManagers_Update_Column>;
  where?: Maybe<ProjectManagers_Bool_Exp>;
};

/** ordering options when selecting data from "projectManagers" */
export type ProjectManagers_Order_By = {
  id?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  properties_aggregate?: Maybe<Properties_Aggregate_Order_By>;
  tickets_aggregate?: Maybe<Tickets_Aggregate_Order_By>;
};

/** primary key columns input for table: "projectManagers" */
export type ProjectManagers_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** select columns of table "projectManagers" */
export enum ProjectManagers_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "projectManagers" */
export type ProjectManagers_Set_Input = {
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type ProjectManagers_Stddev_Fields = {
  __typename?: 'projectManagers_stddev_fields';
  id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "projectManagers" */
export type ProjectManagers_Stddev_Order_By = {
  id?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type ProjectManagers_Stddev_Pop_Fields = {
  __typename?: 'projectManagers_stddev_pop_fields';
  id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "projectManagers" */
export type ProjectManagers_Stddev_Pop_Order_By = {
  id?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type ProjectManagers_Stddev_Samp_Fields = {
  __typename?: 'projectManagers_stddev_samp_fields';
  id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "projectManagers" */
export type ProjectManagers_Stddev_Samp_Order_By = {
  id?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type ProjectManagers_Sum_Fields = {
  __typename?: 'projectManagers_sum_fields';
  id?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "projectManagers" */
export type ProjectManagers_Sum_Order_By = {
  id?: Maybe<Order_By>;
};

/** update columns of table "projectManagers" */
export enum ProjectManagers_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name'
}

/** aggregate var_pop on columns */
export type ProjectManagers_Var_Pop_Fields = {
  __typename?: 'projectManagers_var_pop_fields';
  id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "projectManagers" */
export type ProjectManagers_Var_Pop_Order_By = {
  id?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type ProjectManagers_Var_Samp_Fields = {
  __typename?: 'projectManagers_var_samp_fields';
  id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "projectManagers" */
export type ProjectManagers_Var_Samp_Order_By = {
  id?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type ProjectManagers_Variance_Fields = {
  __typename?: 'projectManagers_variance_fields';
  id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "projectManagers" */
export type ProjectManagers_Variance_Order_By = {
  id?: Maybe<Order_By>;
};

/** columns and relationships of "properties" */
export type Properties = {
  __typename?: 'properties';
  address?: Maybe<Scalars['String']>;
  addressPart?: Maybe<Scalars['String']>;
  arnonaMonthlyAmount?: Maybe<Scalars['money']>;
  /** An array relationship */
  contracts: Array<Contracts>;
  /** An aggregated array relationship */
  contracts_aggregate: Contracts_Aggregate;
  id: Scalars['Int'];
  /** An array relationship */
  insurance_contracts: Array<InsuranceContracts>;
  /** An aggregated array relationship */
  insurance_contracts_aggregate: InsuranceContracts_Aggregate;
  projectManager: Scalars['Int'];
  /** An object relationship */
  projectManagerByProjectManager: ProjectManagers;
};


/** columns and relationships of "properties" */
export type PropertiesContractsArgs = {
  distinct_on?: Maybe<Array<Contracts_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Contracts_Order_By>>;
  where?: Maybe<Contracts_Bool_Exp>;
};


/** columns and relationships of "properties" */
export type PropertiesContracts_AggregateArgs = {
  distinct_on?: Maybe<Array<Contracts_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Contracts_Order_By>>;
  where?: Maybe<Contracts_Bool_Exp>;
};


/** columns and relationships of "properties" */
export type PropertiesInsurance_ContractsArgs = {
  distinct_on?: Maybe<Array<InsuranceContracts_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<InsuranceContracts_Order_By>>;
  where?: Maybe<InsuranceContracts_Bool_Exp>;
};


/** columns and relationships of "properties" */
export type PropertiesInsurance_Contracts_AggregateArgs = {
  distinct_on?: Maybe<Array<InsuranceContracts_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<InsuranceContracts_Order_By>>;
  where?: Maybe<InsuranceContracts_Bool_Exp>;
};

/** aggregated selection of "properties" */
export type Properties_Aggregate = {
  __typename?: 'properties_aggregate';
  aggregate?: Maybe<Properties_Aggregate_Fields>;
  nodes: Array<Properties>;
};

/** aggregate fields of "properties" */
export type Properties_Aggregate_Fields = {
  __typename?: 'properties_aggregate_fields';
  avg?: Maybe<Properties_Avg_Fields>;
  count?: Maybe<Scalars['Int']>;
  max?: Maybe<Properties_Max_Fields>;
  min?: Maybe<Properties_Min_Fields>;
  stddev?: Maybe<Properties_Stddev_Fields>;
  stddev_pop?: Maybe<Properties_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Properties_Stddev_Samp_Fields>;
  sum?: Maybe<Properties_Sum_Fields>;
  var_pop?: Maybe<Properties_Var_Pop_Fields>;
  var_samp?: Maybe<Properties_Var_Samp_Fields>;
  variance?: Maybe<Properties_Variance_Fields>;
};


/** aggregate fields of "properties" */
export type Properties_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Properties_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "properties" */
export type Properties_Aggregate_Order_By = {
  avg?: Maybe<Properties_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Properties_Max_Order_By>;
  min?: Maybe<Properties_Min_Order_By>;
  stddev?: Maybe<Properties_Stddev_Order_By>;
  stddev_pop?: Maybe<Properties_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Properties_Stddev_Samp_Order_By>;
  sum?: Maybe<Properties_Sum_Order_By>;
  var_pop?: Maybe<Properties_Var_Pop_Order_By>;
  var_samp?: Maybe<Properties_Var_Samp_Order_By>;
  variance?: Maybe<Properties_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "properties" */
export type Properties_Arr_Rel_Insert_Input = {
  data: Array<Properties_Insert_Input>;
  on_conflict?: Maybe<Properties_On_Conflict>;
};

/** aggregate avg on columns */
export type Properties_Avg_Fields = {
  __typename?: 'properties_avg_fields';
  arnonaMonthlyAmount?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  projectManager?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "properties" */
export type Properties_Avg_Order_By = {
  arnonaMonthlyAmount?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  projectManager?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "properties". All fields are combined with a logical 'AND'. */
export type Properties_Bool_Exp = {
  _and?: Maybe<Array<Maybe<Properties_Bool_Exp>>>;
  _not?: Maybe<Properties_Bool_Exp>;
  _or?: Maybe<Array<Maybe<Properties_Bool_Exp>>>;
  address?: Maybe<String_Comparison_Exp>;
  addressPart?: Maybe<String_Comparison_Exp>;
  arnonaMonthlyAmount?: Maybe<Money_Comparison_Exp>;
  contracts?: Maybe<Contracts_Bool_Exp>;
  id?: Maybe<Int_Comparison_Exp>;
  insurance_contracts?: Maybe<InsuranceContracts_Bool_Exp>;
  projectManager?: Maybe<Int_Comparison_Exp>;
  projectManagerByProjectManager?: Maybe<ProjectManagers_Bool_Exp>;
};

/** unique or primary key constraints on table "properties" */
export enum Properties_Constraint {
  /** unique or primary key constraint */
  PropertiesPkey = 'properties_pkey'
}

/** input type for incrementing integer column in table "properties" */
export type Properties_Inc_Input = {
  arnonaMonthlyAmount?: Maybe<Scalars['money']>;
  id?: Maybe<Scalars['Int']>;
  projectManager?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "properties" */
export type Properties_Insert_Input = {
  address?: Maybe<Scalars['String']>;
  addressPart?: Maybe<Scalars['String']>;
  arnonaMonthlyAmount?: Maybe<Scalars['money']>;
  contracts?: Maybe<Contracts_Arr_Rel_Insert_Input>;
  id?: Maybe<Scalars['Int']>;
  insurance_contracts?: Maybe<InsuranceContracts_Arr_Rel_Insert_Input>;
  projectManager?: Maybe<Scalars['Int']>;
  projectManagerByProjectManager?: Maybe<ProjectManagers_Obj_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Properties_Max_Fields = {
  __typename?: 'properties_max_fields';
  address?: Maybe<Scalars['String']>;
  addressPart?: Maybe<Scalars['String']>;
  arnonaMonthlyAmount?: Maybe<Scalars['money']>;
  id?: Maybe<Scalars['Int']>;
  projectManager?: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "properties" */
export type Properties_Max_Order_By = {
  address?: Maybe<Order_By>;
  addressPart?: Maybe<Order_By>;
  arnonaMonthlyAmount?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  projectManager?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Properties_Min_Fields = {
  __typename?: 'properties_min_fields';
  address?: Maybe<Scalars['String']>;
  addressPart?: Maybe<Scalars['String']>;
  arnonaMonthlyAmount?: Maybe<Scalars['money']>;
  id?: Maybe<Scalars['Int']>;
  projectManager?: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "properties" */
export type Properties_Min_Order_By = {
  address?: Maybe<Order_By>;
  addressPart?: Maybe<Order_By>;
  arnonaMonthlyAmount?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  projectManager?: Maybe<Order_By>;
};

/** response of any mutation on the table "properties" */
export type Properties_Mutation_Response = {
  __typename?: 'properties_mutation_response';
  /** number of affected rows by the mutation */
  affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  returning: Array<Properties>;
};

/** input type for inserting object relation for remote table "properties" */
export type Properties_Obj_Rel_Insert_Input = {
  data: Properties_Insert_Input;
  on_conflict?: Maybe<Properties_On_Conflict>;
};

/** on conflict condition type for table "properties" */
export type Properties_On_Conflict = {
  constraint: Properties_Constraint;
  update_columns: Array<Properties_Update_Column>;
  where?: Maybe<Properties_Bool_Exp>;
};

/** ordering options when selecting data from "properties" */
export type Properties_Order_By = {
  address?: Maybe<Order_By>;
  addressPart?: Maybe<Order_By>;
  arnonaMonthlyAmount?: Maybe<Order_By>;
  contracts_aggregate?: Maybe<Contracts_Aggregate_Order_By>;
  id?: Maybe<Order_By>;
  insurance_contracts_aggregate?: Maybe<InsuranceContracts_Aggregate_Order_By>;
  projectManager?: Maybe<Order_By>;
  projectManagerByProjectManager?: Maybe<ProjectManagers_Order_By>;
};

/** primary key columns input for table: "properties" */
export type Properties_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** select columns of table "properties" */
export enum Properties_Select_Column {
  /** column name */
  Address = 'address',
  /** column name */
  AddressPart = 'addressPart',
  /** column name */
  ArnonaMonthlyAmount = 'arnonaMonthlyAmount',
  /** column name */
  Id = 'id',
  /** column name */
  ProjectManager = 'projectManager'
}

/** input type for updating data in table "properties" */
export type Properties_Set_Input = {
  address?: Maybe<Scalars['String']>;
  addressPart?: Maybe<Scalars['String']>;
  arnonaMonthlyAmount?: Maybe<Scalars['money']>;
  id?: Maybe<Scalars['Int']>;
  projectManager?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Properties_Stddev_Fields = {
  __typename?: 'properties_stddev_fields';
  arnonaMonthlyAmount?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  projectManager?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "properties" */
export type Properties_Stddev_Order_By = {
  arnonaMonthlyAmount?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  projectManager?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Properties_Stddev_Pop_Fields = {
  __typename?: 'properties_stddev_pop_fields';
  arnonaMonthlyAmount?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  projectManager?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "properties" */
export type Properties_Stddev_Pop_Order_By = {
  arnonaMonthlyAmount?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  projectManager?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Properties_Stddev_Samp_Fields = {
  __typename?: 'properties_stddev_samp_fields';
  arnonaMonthlyAmount?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  projectManager?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "properties" */
export type Properties_Stddev_Samp_Order_By = {
  arnonaMonthlyAmount?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  projectManager?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Properties_Sum_Fields = {
  __typename?: 'properties_sum_fields';
  arnonaMonthlyAmount?: Maybe<Scalars['money']>;
  id?: Maybe<Scalars['Int']>;
  projectManager?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "properties" */
export type Properties_Sum_Order_By = {
  arnonaMonthlyAmount?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  projectManager?: Maybe<Order_By>;
};

/** update columns of table "properties" */
export enum Properties_Update_Column {
  /** column name */
  Address = 'address',
  /** column name */
  AddressPart = 'addressPart',
  /** column name */
  ArnonaMonthlyAmount = 'arnonaMonthlyAmount',
  /** column name */
  Id = 'id',
  /** column name */
  ProjectManager = 'projectManager'
}

/** aggregate var_pop on columns */
export type Properties_Var_Pop_Fields = {
  __typename?: 'properties_var_pop_fields';
  arnonaMonthlyAmount?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  projectManager?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "properties" */
export type Properties_Var_Pop_Order_By = {
  arnonaMonthlyAmount?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  projectManager?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Properties_Var_Samp_Fields = {
  __typename?: 'properties_var_samp_fields';
  arnonaMonthlyAmount?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  projectManager?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "properties" */
export type Properties_Var_Samp_Order_By = {
  arnonaMonthlyAmount?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  projectManager?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Properties_Variance_Fields = {
  __typename?: 'properties_variance_fields';
  arnonaMonthlyAmount?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  projectManager?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "properties" */
export type Properties_Variance_Order_By = {
  arnonaMonthlyAmount?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  projectManager?: Maybe<Order_By>;
};

/** query root */
export type Query_Root = {
  __typename?: 'query_root';
  /** fetch data from the table: "contracts" */
  contracts: Array<Contracts>;
  /** fetch data from the table: "contractsRentersRelation" */
  contractsRentersRelation: Array<ContractsRentersRelation>;
  /** fetch aggregated fields from the table: "contractsRentersRelation" */
  contractsRentersRelation_aggregate: ContractsRentersRelation_Aggregate;
  /** fetch data from the table: "contractsRentersRelation" using primary key columns */
  contractsRentersRelation_by_pk?: Maybe<ContractsRentersRelation>;
  /** fetch aggregated fields from the table: "contracts" */
  contracts_aggregate: Contracts_Aggregate;
  /** fetch data from the table: "contracts" using primary key columns */
  contracts_by_pk?: Maybe<Contracts>;
  /** fetch data from the table: "entities" */
  entities: Array<Entities>;
  /** fetch aggregated fields from the table: "entities" */
  entities_aggregate: Entities_Aggregate;
  /** fetch data from the table: "entities" using primary key columns */
  entities_by_pk?: Maybe<Entities>;
  /** fetch data from the table: "insuranceContracts" */
  insuranceContracts: Array<InsuranceContracts>;
  /** fetch aggregated fields from the table: "insuranceContracts" */
  insuranceContracts_aggregate: InsuranceContracts_Aggregate;
  /** fetch data from the table: "insuranceContracts" using primary key columns */
  insuranceContracts_by_pk?: Maybe<InsuranceContracts>;
  /** fetch data from the table: "payMethods" */
  payMethods: Array<PayMethods>;
  /** fetch aggregated fields from the table: "payMethods" */
  payMethods_aggregate: PayMethods_Aggregate;
  /** fetch data from the table: "payMethods" using primary key columns */
  payMethods_by_pk?: Maybe<PayMethods>;
  /** fetch data from the table: "payments" */
  payments: Array<Payments>;
  /** fetch aggregated fields from the table: "payments" */
  payments_aggregate: Payments_Aggregate;
  /** fetch data from the table: "payments" using primary key columns */
  payments_by_pk?: Maybe<Payments>;
  /** fetch data from the table: "projectManagers" */
  projectManagers: Array<ProjectManagers>;
  /** fetch aggregated fields from the table: "projectManagers" */
  projectManagers_aggregate: ProjectManagers_Aggregate;
  /** fetch data from the table: "projectManagers" using primary key columns */
  projectManagers_by_pk?: Maybe<ProjectManagers>;
  /** fetch data from the table: "properties" */
  properties: Array<Properties>;
  /** fetch aggregated fields from the table: "properties" */
  properties_aggregate: Properties_Aggregate;
  /** fetch data from the table: "properties" using primary key columns */
  properties_by_pk?: Maybe<Properties>;
  /** fetch data from the table: "ticketTypes" */
  ticketTypes: Array<TicketTypes>;
  /** fetch aggregated fields from the table: "ticketTypes" */
  ticketTypes_aggregate: TicketTypes_Aggregate;
  /** fetch data from the table: "ticketTypes" using primary key columns */
  ticketTypes_by_pk?: Maybe<TicketTypes>;
  /** fetch data from the table: "tickets" */
  tickets: Array<Tickets>;
  /** fetch aggregated fields from the table: "tickets" */
  tickets_aggregate: Tickets_Aggregate;
  /** fetch data from the table: "tickets" using primary key columns */
  tickets_by_pk?: Maybe<Tickets>;
};


/** query root */
export type Query_RootContractsArgs = {
  distinct_on?: Maybe<Array<Contracts_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Contracts_Order_By>>;
  where?: Maybe<Contracts_Bool_Exp>;
};


/** query root */
export type Query_RootContractsRentersRelationArgs = {
  distinct_on?: Maybe<Array<ContractsRentersRelation_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<ContractsRentersRelation_Order_By>>;
  where?: Maybe<ContractsRentersRelation_Bool_Exp>;
};


/** query root */
export type Query_RootContractsRentersRelation_AggregateArgs = {
  distinct_on?: Maybe<Array<ContractsRentersRelation_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<ContractsRentersRelation_Order_By>>;
  where?: Maybe<ContractsRentersRelation_Bool_Exp>;
};


/** query root */
export type Query_RootContractsRentersRelation_By_PkArgs = {
  contractId: Scalars['Int'];
  renterId: Scalars['Int'];
};


/** query root */
export type Query_RootContracts_AggregateArgs = {
  distinct_on?: Maybe<Array<Contracts_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Contracts_Order_By>>;
  where?: Maybe<Contracts_Bool_Exp>;
};


/** query root */
export type Query_RootContracts_By_PkArgs = {
  id: Scalars['Int'];
};


/** query root */
export type Query_RootEntitiesArgs = {
  distinct_on?: Maybe<Array<Entities_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Entities_Order_By>>;
  where?: Maybe<Entities_Bool_Exp>;
};


/** query root */
export type Query_RootEntities_AggregateArgs = {
  distinct_on?: Maybe<Array<Entities_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Entities_Order_By>>;
  where?: Maybe<Entities_Bool_Exp>;
};


/** query root */
export type Query_RootEntities_By_PkArgs = {
  id: Scalars['Int'];
};


/** query root */
export type Query_RootInsuranceContractsArgs = {
  distinct_on?: Maybe<Array<InsuranceContracts_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<InsuranceContracts_Order_By>>;
  where?: Maybe<InsuranceContracts_Bool_Exp>;
};


/** query root */
export type Query_RootInsuranceContracts_AggregateArgs = {
  distinct_on?: Maybe<Array<InsuranceContracts_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<InsuranceContracts_Order_By>>;
  where?: Maybe<InsuranceContracts_Bool_Exp>;
};


/** query root */
export type Query_RootInsuranceContracts_By_PkArgs = {
  id: Scalars['Int'];
};


/** query root */
export type Query_RootPayMethodsArgs = {
  distinct_on?: Maybe<Array<PayMethods_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<PayMethods_Order_By>>;
  where?: Maybe<PayMethods_Bool_Exp>;
};


/** query root */
export type Query_RootPayMethods_AggregateArgs = {
  distinct_on?: Maybe<Array<PayMethods_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<PayMethods_Order_By>>;
  where?: Maybe<PayMethods_Bool_Exp>;
};


/** query root */
export type Query_RootPayMethods_By_PkArgs = {
  id: Scalars['Int'];
};


/** query root */
export type Query_RootPaymentsArgs = {
  distinct_on?: Maybe<Array<Payments_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Payments_Order_By>>;
  where?: Maybe<Payments_Bool_Exp>;
};


/** query root */
export type Query_RootPayments_AggregateArgs = {
  distinct_on?: Maybe<Array<Payments_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Payments_Order_By>>;
  where?: Maybe<Payments_Bool_Exp>;
};


/** query root */
export type Query_RootPayments_By_PkArgs = {
  id: Scalars['Int'];
};


/** query root */
export type Query_RootProjectManagersArgs = {
  distinct_on?: Maybe<Array<ProjectManagers_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<ProjectManagers_Order_By>>;
  where?: Maybe<ProjectManagers_Bool_Exp>;
};


/** query root */
export type Query_RootProjectManagers_AggregateArgs = {
  distinct_on?: Maybe<Array<ProjectManagers_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<ProjectManagers_Order_By>>;
  where?: Maybe<ProjectManagers_Bool_Exp>;
};


/** query root */
export type Query_RootProjectManagers_By_PkArgs = {
  id: Scalars['Int'];
};


/** query root */
export type Query_RootPropertiesArgs = {
  distinct_on?: Maybe<Array<Properties_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Properties_Order_By>>;
  where?: Maybe<Properties_Bool_Exp>;
};


/** query root */
export type Query_RootProperties_AggregateArgs = {
  distinct_on?: Maybe<Array<Properties_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Properties_Order_By>>;
  where?: Maybe<Properties_Bool_Exp>;
};


/** query root */
export type Query_RootProperties_By_PkArgs = {
  id: Scalars['Int'];
};


/** query root */
export type Query_RootTicketTypesArgs = {
  distinct_on?: Maybe<Array<TicketTypes_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<TicketTypes_Order_By>>;
  where?: Maybe<TicketTypes_Bool_Exp>;
};


/** query root */
export type Query_RootTicketTypes_AggregateArgs = {
  distinct_on?: Maybe<Array<TicketTypes_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<TicketTypes_Order_By>>;
  where?: Maybe<TicketTypes_Bool_Exp>;
};


/** query root */
export type Query_RootTicketTypes_By_PkArgs = {
  id: Scalars['Int'];
};


/** query root */
export type Query_RootTicketsArgs = {
  distinct_on?: Maybe<Array<Tickets_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tickets_Order_By>>;
  where?: Maybe<Tickets_Bool_Exp>;
};


/** query root */
export type Query_RootTickets_AggregateArgs = {
  distinct_on?: Maybe<Array<Tickets_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tickets_Order_By>>;
  where?: Maybe<Tickets_Bool_Exp>;
};


/** query root */
export type Query_RootTickets_By_PkArgs = {
  id: Scalars['Int'];
};

/** subscription root */
export type Subscription_Root = {
  __typename?: 'subscription_root';
  /** fetch data from the table: "contracts" */
  contracts: Array<Contracts>;
  /** fetch data from the table: "contractsRentersRelation" */
  contractsRentersRelation: Array<ContractsRentersRelation>;
  /** fetch aggregated fields from the table: "contractsRentersRelation" */
  contractsRentersRelation_aggregate: ContractsRentersRelation_Aggregate;
  /** fetch data from the table: "contractsRentersRelation" using primary key columns */
  contractsRentersRelation_by_pk?: Maybe<ContractsRentersRelation>;
  /** fetch aggregated fields from the table: "contracts" */
  contracts_aggregate: Contracts_Aggregate;
  /** fetch data from the table: "contracts" using primary key columns */
  contracts_by_pk?: Maybe<Contracts>;
  /** fetch data from the table: "entities" */
  entities: Array<Entities>;
  /** fetch aggregated fields from the table: "entities" */
  entities_aggregate: Entities_Aggregate;
  /** fetch data from the table: "entities" using primary key columns */
  entities_by_pk?: Maybe<Entities>;
  /** fetch data from the table: "insuranceContracts" */
  insuranceContracts: Array<InsuranceContracts>;
  /** fetch aggregated fields from the table: "insuranceContracts" */
  insuranceContracts_aggregate: InsuranceContracts_Aggregate;
  /** fetch data from the table: "insuranceContracts" using primary key columns */
  insuranceContracts_by_pk?: Maybe<InsuranceContracts>;
  /** fetch data from the table: "payMethods" */
  payMethods: Array<PayMethods>;
  /** fetch aggregated fields from the table: "payMethods" */
  payMethods_aggregate: PayMethods_Aggregate;
  /** fetch data from the table: "payMethods" using primary key columns */
  payMethods_by_pk?: Maybe<PayMethods>;
  /** fetch data from the table: "payments" */
  payments: Array<Payments>;
  /** fetch aggregated fields from the table: "payments" */
  payments_aggregate: Payments_Aggregate;
  /** fetch data from the table: "payments" using primary key columns */
  payments_by_pk?: Maybe<Payments>;
  /** fetch data from the table: "projectManagers" */
  projectManagers: Array<ProjectManagers>;
  /** fetch aggregated fields from the table: "projectManagers" */
  projectManagers_aggregate: ProjectManagers_Aggregate;
  /** fetch data from the table: "projectManagers" using primary key columns */
  projectManagers_by_pk?: Maybe<ProjectManagers>;
  /** fetch data from the table: "properties" */
  properties: Array<Properties>;
  /** fetch aggregated fields from the table: "properties" */
  properties_aggregate: Properties_Aggregate;
  /** fetch data from the table: "properties" using primary key columns */
  properties_by_pk?: Maybe<Properties>;
  /** fetch data from the table: "ticketTypes" */
  ticketTypes: Array<TicketTypes>;
  /** fetch aggregated fields from the table: "ticketTypes" */
  ticketTypes_aggregate: TicketTypes_Aggregate;
  /** fetch data from the table: "ticketTypes" using primary key columns */
  ticketTypes_by_pk?: Maybe<TicketTypes>;
  /** fetch data from the table: "tickets" */
  tickets: Array<Tickets>;
  /** fetch aggregated fields from the table: "tickets" */
  tickets_aggregate: Tickets_Aggregate;
  /** fetch data from the table: "tickets" using primary key columns */
  tickets_by_pk?: Maybe<Tickets>;
};


/** subscription root */
export type Subscription_RootContractsArgs = {
  distinct_on?: Maybe<Array<Contracts_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Contracts_Order_By>>;
  where?: Maybe<Contracts_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContractsRentersRelationArgs = {
  distinct_on?: Maybe<Array<ContractsRentersRelation_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<ContractsRentersRelation_Order_By>>;
  where?: Maybe<ContractsRentersRelation_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContractsRentersRelation_AggregateArgs = {
  distinct_on?: Maybe<Array<ContractsRentersRelation_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<ContractsRentersRelation_Order_By>>;
  where?: Maybe<ContractsRentersRelation_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContractsRentersRelation_By_PkArgs = {
  contractId: Scalars['Int'];
  renterId: Scalars['Int'];
};


/** subscription root */
export type Subscription_RootContracts_AggregateArgs = {
  distinct_on?: Maybe<Array<Contracts_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Contracts_Order_By>>;
  where?: Maybe<Contracts_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContracts_By_PkArgs = {
  id: Scalars['Int'];
};


/** subscription root */
export type Subscription_RootEntitiesArgs = {
  distinct_on?: Maybe<Array<Entities_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Entities_Order_By>>;
  where?: Maybe<Entities_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootEntities_AggregateArgs = {
  distinct_on?: Maybe<Array<Entities_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Entities_Order_By>>;
  where?: Maybe<Entities_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootEntities_By_PkArgs = {
  id: Scalars['Int'];
};


/** subscription root */
export type Subscription_RootInsuranceContractsArgs = {
  distinct_on?: Maybe<Array<InsuranceContracts_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<InsuranceContracts_Order_By>>;
  where?: Maybe<InsuranceContracts_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootInsuranceContracts_AggregateArgs = {
  distinct_on?: Maybe<Array<InsuranceContracts_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<InsuranceContracts_Order_By>>;
  where?: Maybe<InsuranceContracts_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootInsuranceContracts_By_PkArgs = {
  id: Scalars['Int'];
};


/** subscription root */
export type Subscription_RootPayMethodsArgs = {
  distinct_on?: Maybe<Array<PayMethods_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<PayMethods_Order_By>>;
  where?: Maybe<PayMethods_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootPayMethods_AggregateArgs = {
  distinct_on?: Maybe<Array<PayMethods_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<PayMethods_Order_By>>;
  where?: Maybe<PayMethods_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootPayMethods_By_PkArgs = {
  id: Scalars['Int'];
};


/** subscription root */
export type Subscription_RootPaymentsArgs = {
  distinct_on?: Maybe<Array<Payments_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Payments_Order_By>>;
  where?: Maybe<Payments_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootPayments_AggregateArgs = {
  distinct_on?: Maybe<Array<Payments_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Payments_Order_By>>;
  where?: Maybe<Payments_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootPayments_By_PkArgs = {
  id: Scalars['Int'];
};


/** subscription root */
export type Subscription_RootProjectManagersArgs = {
  distinct_on?: Maybe<Array<ProjectManagers_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<ProjectManagers_Order_By>>;
  where?: Maybe<ProjectManagers_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootProjectManagers_AggregateArgs = {
  distinct_on?: Maybe<Array<ProjectManagers_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<ProjectManagers_Order_By>>;
  where?: Maybe<ProjectManagers_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootProjectManagers_By_PkArgs = {
  id: Scalars['Int'];
};


/** subscription root */
export type Subscription_RootPropertiesArgs = {
  distinct_on?: Maybe<Array<Properties_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Properties_Order_By>>;
  where?: Maybe<Properties_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootProperties_AggregateArgs = {
  distinct_on?: Maybe<Array<Properties_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Properties_Order_By>>;
  where?: Maybe<Properties_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootProperties_By_PkArgs = {
  id: Scalars['Int'];
};


/** subscription root */
export type Subscription_RootTicketTypesArgs = {
  distinct_on?: Maybe<Array<TicketTypes_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<TicketTypes_Order_By>>;
  where?: Maybe<TicketTypes_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootTicketTypes_AggregateArgs = {
  distinct_on?: Maybe<Array<TicketTypes_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<TicketTypes_Order_By>>;
  where?: Maybe<TicketTypes_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootTicketTypes_By_PkArgs = {
  id: Scalars['Int'];
};


/** subscription root */
export type Subscription_RootTicketsArgs = {
  distinct_on?: Maybe<Array<Tickets_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tickets_Order_By>>;
  where?: Maybe<Tickets_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootTickets_AggregateArgs = {
  distinct_on?: Maybe<Array<Tickets_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tickets_Order_By>>;
  where?: Maybe<Tickets_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootTickets_By_PkArgs = {
  id: Scalars['Int'];
};

/**
 * enum
 * 
 * 
 * columns and relationships of "ticketTypes"
 */
export type TicketTypes = {
  __typename?: 'ticketTypes';
  id: Scalars['Int'];
  /** An array relationship */
  tickets: Array<Tickets>;
  /** An aggregated array relationship */
  tickets_aggregate: Tickets_Aggregate;
  type: Scalars['String'];
  whatToDo?: Maybe<Scalars['String']>;
};


/**
 * enum
 * 
 * 
 * columns and relationships of "ticketTypes"
 */
export type TicketTypesTicketsArgs = {
  distinct_on?: Maybe<Array<Tickets_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tickets_Order_By>>;
  where?: Maybe<Tickets_Bool_Exp>;
};


/**
 * enum
 * 
 * 
 * columns and relationships of "ticketTypes"
 */
export type TicketTypesTickets_AggregateArgs = {
  distinct_on?: Maybe<Array<Tickets_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tickets_Order_By>>;
  where?: Maybe<Tickets_Bool_Exp>;
};

/** aggregated selection of "ticketTypes" */
export type TicketTypes_Aggregate = {
  __typename?: 'ticketTypes_aggregate';
  aggregate?: Maybe<TicketTypes_Aggregate_Fields>;
  nodes: Array<TicketTypes>;
};

/** aggregate fields of "ticketTypes" */
export type TicketTypes_Aggregate_Fields = {
  __typename?: 'ticketTypes_aggregate_fields';
  avg?: Maybe<TicketTypes_Avg_Fields>;
  count?: Maybe<Scalars['Int']>;
  max?: Maybe<TicketTypes_Max_Fields>;
  min?: Maybe<TicketTypes_Min_Fields>;
  stddev?: Maybe<TicketTypes_Stddev_Fields>;
  stddev_pop?: Maybe<TicketTypes_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<TicketTypes_Stddev_Samp_Fields>;
  sum?: Maybe<TicketTypes_Sum_Fields>;
  var_pop?: Maybe<TicketTypes_Var_Pop_Fields>;
  var_samp?: Maybe<TicketTypes_Var_Samp_Fields>;
  variance?: Maybe<TicketTypes_Variance_Fields>;
};


/** aggregate fields of "ticketTypes" */
export type TicketTypes_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<TicketTypes_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "ticketTypes" */
export type TicketTypes_Aggregate_Order_By = {
  avg?: Maybe<TicketTypes_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<TicketTypes_Max_Order_By>;
  min?: Maybe<TicketTypes_Min_Order_By>;
  stddev?: Maybe<TicketTypes_Stddev_Order_By>;
  stddev_pop?: Maybe<TicketTypes_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<TicketTypes_Stddev_Samp_Order_By>;
  sum?: Maybe<TicketTypes_Sum_Order_By>;
  var_pop?: Maybe<TicketTypes_Var_Pop_Order_By>;
  var_samp?: Maybe<TicketTypes_Var_Samp_Order_By>;
  variance?: Maybe<TicketTypes_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "ticketTypes" */
export type TicketTypes_Arr_Rel_Insert_Input = {
  data: Array<TicketTypes_Insert_Input>;
  on_conflict?: Maybe<TicketTypes_On_Conflict>;
};

/** aggregate avg on columns */
export type TicketTypes_Avg_Fields = {
  __typename?: 'ticketTypes_avg_fields';
  id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "ticketTypes" */
export type TicketTypes_Avg_Order_By = {
  id?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "ticketTypes". All fields are combined with a logical 'AND'. */
export type TicketTypes_Bool_Exp = {
  _and?: Maybe<Array<Maybe<TicketTypes_Bool_Exp>>>;
  _not?: Maybe<TicketTypes_Bool_Exp>;
  _or?: Maybe<Array<Maybe<TicketTypes_Bool_Exp>>>;
  id?: Maybe<Int_Comparison_Exp>;
  tickets?: Maybe<Tickets_Bool_Exp>;
  type?: Maybe<String_Comparison_Exp>;
  whatToDo?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "ticketTypes" */
export enum TicketTypes_Constraint {
  /** unique or primary key constraint */
  TicketTypesPkey = 'ticket_types_pkey',
  /** unique or primary key constraint */
  TicketTypesTypeKey = 'ticket_types_type_key'
}

/** input type for incrementing integer column in table "ticketTypes" */
export type TicketTypes_Inc_Input = {
  id?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "ticketTypes" */
export type TicketTypes_Insert_Input = {
  id?: Maybe<Scalars['Int']>;
  tickets?: Maybe<Tickets_Arr_Rel_Insert_Input>;
  type?: Maybe<Scalars['String']>;
  whatToDo?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type TicketTypes_Max_Fields = {
  __typename?: 'ticketTypes_max_fields';
  id?: Maybe<Scalars['Int']>;
  type?: Maybe<Scalars['String']>;
  whatToDo?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "ticketTypes" */
export type TicketTypes_Max_Order_By = {
  id?: Maybe<Order_By>;
  type?: Maybe<Order_By>;
  whatToDo?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type TicketTypes_Min_Fields = {
  __typename?: 'ticketTypes_min_fields';
  id?: Maybe<Scalars['Int']>;
  type?: Maybe<Scalars['String']>;
  whatToDo?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "ticketTypes" */
export type TicketTypes_Min_Order_By = {
  id?: Maybe<Order_By>;
  type?: Maybe<Order_By>;
  whatToDo?: Maybe<Order_By>;
};

/** response of any mutation on the table "ticketTypes" */
export type TicketTypes_Mutation_Response = {
  __typename?: 'ticketTypes_mutation_response';
  /** number of affected rows by the mutation */
  affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  returning: Array<TicketTypes>;
};

/** input type for inserting object relation for remote table "ticketTypes" */
export type TicketTypes_Obj_Rel_Insert_Input = {
  data: TicketTypes_Insert_Input;
  on_conflict?: Maybe<TicketTypes_On_Conflict>;
};

/** on conflict condition type for table "ticketTypes" */
export type TicketTypes_On_Conflict = {
  constraint: TicketTypes_Constraint;
  update_columns: Array<TicketTypes_Update_Column>;
  where?: Maybe<TicketTypes_Bool_Exp>;
};

/** ordering options when selecting data from "ticketTypes" */
export type TicketTypes_Order_By = {
  id?: Maybe<Order_By>;
  tickets_aggregate?: Maybe<Tickets_Aggregate_Order_By>;
  type?: Maybe<Order_By>;
  whatToDo?: Maybe<Order_By>;
};

/** primary key columns input for table: "ticketTypes" */
export type TicketTypes_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** select columns of table "ticketTypes" */
export enum TicketTypes_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Type = 'type',
  /** column name */
  WhatToDo = 'whatToDo'
}

/** input type for updating data in table "ticketTypes" */
export type TicketTypes_Set_Input = {
  id?: Maybe<Scalars['Int']>;
  type?: Maybe<Scalars['String']>;
  whatToDo?: Maybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type TicketTypes_Stddev_Fields = {
  __typename?: 'ticketTypes_stddev_fields';
  id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "ticketTypes" */
export type TicketTypes_Stddev_Order_By = {
  id?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type TicketTypes_Stddev_Pop_Fields = {
  __typename?: 'ticketTypes_stddev_pop_fields';
  id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "ticketTypes" */
export type TicketTypes_Stddev_Pop_Order_By = {
  id?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type TicketTypes_Stddev_Samp_Fields = {
  __typename?: 'ticketTypes_stddev_samp_fields';
  id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "ticketTypes" */
export type TicketTypes_Stddev_Samp_Order_By = {
  id?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type TicketTypes_Sum_Fields = {
  __typename?: 'ticketTypes_sum_fields';
  id?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "ticketTypes" */
export type TicketTypes_Sum_Order_By = {
  id?: Maybe<Order_By>;
};

/** update columns of table "ticketTypes" */
export enum TicketTypes_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Type = 'type',
  /** column name */
  WhatToDo = 'whatToDo'
}

/** aggregate var_pop on columns */
export type TicketTypes_Var_Pop_Fields = {
  __typename?: 'ticketTypes_var_pop_fields';
  id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "ticketTypes" */
export type TicketTypes_Var_Pop_Order_By = {
  id?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type TicketTypes_Var_Samp_Fields = {
  __typename?: 'ticketTypes_var_samp_fields';
  id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "ticketTypes" */
export type TicketTypes_Var_Samp_Order_By = {
  id?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type TicketTypes_Variance_Fields = {
  __typename?: 'ticketTypes_variance_fields';
  id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "ticketTypes" */
export type TicketTypes_Variance_Order_By = {
  id?: Maybe<Order_By>;
};

/** columns and relationships of "tickets" */
export type Tickets = {
  __typename?: 'tickets';
  /** An object relationship */
  contract?: Maybe<Contracts>;
  contractId?: Maybe<Scalars['Int']>;
  id: Scalars['Int'];
  openingDate: Scalars['date'];
  /** An object relationship */
  payment?: Maybe<Payments>;
  paymentId?: Maybe<Scalars['Int']>;
  projectManagerId: Scalars['Int'];
  /** An object relationship */
  project_manager: ProjectManagers;
  /** An object relationship */
  ticket_type: TicketTypes;
  tieckTypeId: Scalars['Int'];
};

/** aggregated selection of "tickets" */
export type Tickets_Aggregate = {
  __typename?: 'tickets_aggregate';
  aggregate?: Maybe<Tickets_Aggregate_Fields>;
  nodes: Array<Tickets>;
};

/** aggregate fields of "tickets" */
export type Tickets_Aggregate_Fields = {
  __typename?: 'tickets_aggregate_fields';
  avg?: Maybe<Tickets_Avg_Fields>;
  count?: Maybe<Scalars['Int']>;
  max?: Maybe<Tickets_Max_Fields>;
  min?: Maybe<Tickets_Min_Fields>;
  stddev?: Maybe<Tickets_Stddev_Fields>;
  stddev_pop?: Maybe<Tickets_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Tickets_Stddev_Samp_Fields>;
  sum?: Maybe<Tickets_Sum_Fields>;
  var_pop?: Maybe<Tickets_Var_Pop_Fields>;
  var_samp?: Maybe<Tickets_Var_Samp_Fields>;
  variance?: Maybe<Tickets_Variance_Fields>;
};


/** aggregate fields of "tickets" */
export type Tickets_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Tickets_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "tickets" */
export type Tickets_Aggregate_Order_By = {
  avg?: Maybe<Tickets_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Tickets_Max_Order_By>;
  min?: Maybe<Tickets_Min_Order_By>;
  stddev?: Maybe<Tickets_Stddev_Order_By>;
  stddev_pop?: Maybe<Tickets_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Tickets_Stddev_Samp_Order_By>;
  sum?: Maybe<Tickets_Sum_Order_By>;
  var_pop?: Maybe<Tickets_Var_Pop_Order_By>;
  var_samp?: Maybe<Tickets_Var_Samp_Order_By>;
  variance?: Maybe<Tickets_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "tickets" */
export type Tickets_Arr_Rel_Insert_Input = {
  data: Array<Tickets_Insert_Input>;
  on_conflict?: Maybe<Tickets_On_Conflict>;
};

/** aggregate avg on columns */
export type Tickets_Avg_Fields = {
  __typename?: 'tickets_avg_fields';
  contractId?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  paymentId?: Maybe<Scalars['Float']>;
  projectManagerId?: Maybe<Scalars['Float']>;
  tieckTypeId?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "tickets" */
export type Tickets_Avg_Order_By = {
  contractId?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  paymentId?: Maybe<Order_By>;
  projectManagerId?: Maybe<Order_By>;
  tieckTypeId?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "tickets". All fields are combined with a logical 'AND'. */
export type Tickets_Bool_Exp = {
  _and?: Maybe<Array<Maybe<Tickets_Bool_Exp>>>;
  _not?: Maybe<Tickets_Bool_Exp>;
  _or?: Maybe<Array<Maybe<Tickets_Bool_Exp>>>;
  contract?: Maybe<Contracts_Bool_Exp>;
  contractId?: Maybe<Int_Comparison_Exp>;
  id?: Maybe<Int_Comparison_Exp>;
  openingDate?: Maybe<Date_Comparison_Exp>;
  payment?: Maybe<Payments_Bool_Exp>;
  paymentId?: Maybe<Int_Comparison_Exp>;
  projectManagerId?: Maybe<Int_Comparison_Exp>;
  project_manager?: Maybe<ProjectManagers_Bool_Exp>;
  ticket_type?: Maybe<TicketTypes_Bool_Exp>;
  tieckTypeId?: Maybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "tickets" */
export enum Tickets_Constraint {
  /** unique or primary key constraint */
  TicketPkey = 'ticket_pkey'
}

/** input type for incrementing integer column in table "tickets" */
export type Tickets_Inc_Input = {
  contractId?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  paymentId?: Maybe<Scalars['Int']>;
  projectManagerId?: Maybe<Scalars['Int']>;
  tieckTypeId?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "tickets" */
export type Tickets_Insert_Input = {
  contract?: Maybe<Contracts_Obj_Rel_Insert_Input>;
  contractId?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  openingDate?: Maybe<Scalars['date']>;
  payment?: Maybe<Payments_Obj_Rel_Insert_Input>;
  paymentId?: Maybe<Scalars['Int']>;
  projectManagerId?: Maybe<Scalars['Int']>;
  project_manager?: Maybe<ProjectManagers_Obj_Rel_Insert_Input>;
  ticket_type?: Maybe<TicketTypes_Obj_Rel_Insert_Input>;
  tieckTypeId?: Maybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Tickets_Max_Fields = {
  __typename?: 'tickets_max_fields';
  contractId?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  openingDate?: Maybe<Scalars['date']>;
  paymentId?: Maybe<Scalars['Int']>;
  projectManagerId?: Maybe<Scalars['Int']>;
  tieckTypeId?: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "tickets" */
export type Tickets_Max_Order_By = {
  contractId?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  openingDate?: Maybe<Order_By>;
  paymentId?: Maybe<Order_By>;
  projectManagerId?: Maybe<Order_By>;
  tieckTypeId?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Tickets_Min_Fields = {
  __typename?: 'tickets_min_fields';
  contractId?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  openingDate?: Maybe<Scalars['date']>;
  paymentId?: Maybe<Scalars['Int']>;
  projectManagerId?: Maybe<Scalars['Int']>;
  tieckTypeId?: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "tickets" */
export type Tickets_Min_Order_By = {
  contractId?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  openingDate?: Maybe<Order_By>;
  paymentId?: Maybe<Order_By>;
  projectManagerId?: Maybe<Order_By>;
  tieckTypeId?: Maybe<Order_By>;
};

/** response of any mutation on the table "tickets" */
export type Tickets_Mutation_Response = {
  __typename?: 'tickets_mutation_response';
  /** number of affected rows by the mutation */
  affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  returning: Array<Tickets>;
};

/** input type for inserting object relation for remote table "tickets" */
export type Tickets_Obj_Rel_Insert_Input = {
  data: Tickets_Insert_Input;
  on_conflict?: Maybe<Tickets_On_Conflict>;
};

/** on conflict condition type for table "tickets" */
export type Tickets_On_Conflict = {
  constraint: Tickets_Constraint;
  update_columns: Array<Tickets_Update_Column>;
  where?: Maybe<Tickets_Bool_Exp>;
};

/** ordering options when selecting data from "tickets" */
export type Tickets_Order_By = {
  contract?: Maybe<Contracts_Order_By>;
  contractId?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  openingDate?: Maybe<Order_By>;
  payment?: Maybe<Payments_Order_By>;
  paymentId?: Maybe<Order_By>;
  projectManagerId?: Maybe<Order_By>;
  project_manager?: Maybe<ProjectManagers_Order_By>;
  ticket_type?: Maybe<TicketTypes_Order_By>;
  tieckTypeId?: Maybe<Order_By>;
};

/** primary key columns input for table: "tickets" */
export type Tickets_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** select columns of table "tickets" */
export enum Tickets_Select_Column {
  /** column name */
  ContractId = 'contractId',
  /** column name */
  Id = 'id',
  /** column name */
  OpeningDate = 'openingDate',
  /** column name */
  PaymentId = 'paymentId',
  /** column name */
  ProjectManagerId = 'projectManagerId',
  /** column name */
  TieckTypeId = 'tieckTypeId'
}

/** input type for updating data in table "tickets" */
export type Tickets_Set_Input = {
  contractId?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  openingDate?: Maybe<Scalars['date']>;
  paymentId?: Maybe<Scalars['Int']>;
  projectManagerId?: Maybe<Scalars['Int']>;
  tieckTypeId?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Tickets_Stddev_Fields = {
  __typename?: 'tickets_stddev_fields';
  contractId?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  paymentId?: Maybe<Scalars['Float']>;
  projectManagerId?: Maybe<Scalars['Float']>;
  tieckTypeId?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "tickets" */
export type Tickets_Stddev_Order_By = {
  contractId?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  paymentId?: Maybe<Order_By>;
  projectManagerId?: Maybe<Order_By>;
  tieckTypeId?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Tickets_Stddev_Pop_Fields = {
  __typename?: 'tickets_stddev_pop_fields';
  contractId?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  paymentId?: Maybe<Scalars['Float']>;
  projectManagerId?: Maybe<Scalars['Float']>;
  tieckTypeId?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "tickets" */
export type Tickets_Stddev_Pop_Order_By = {
  contractId?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  paymentId?: Maybe<Order_By>;
  projectManagerId?: Maybe<Order_By>;
  tieckTypeId?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Tickets_Stddev_Samp_Fields = {
  __typename?: 'tickets_stddev_samp_fields';
  contractId?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  paymentId?: Maybe<Scalars['Float']>;
  projectManagerId?: Maybe<Scalars['Float']>;
  tieckTypeId?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "tickets" */
export type Tickets_Stddev_Samp_Order_By = {
  contractId?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  paymentId?: Maybe<Order_By>;
  projectManagerId?: Maybe<Order_By>;
  tieckTypeId?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Tickets_Sum_Fields = {
  __typename?: 'tickets_sum_fields';
  contractId?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  paymentId?: Maybe<Scalars['Int']>;
  projectManagerId?: Maybe<Scalars['Int']>;
  tieckTypeId?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "tickets" */
export type Tickets_Sum_Order_By = {
  contractId?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  paymentId?: Maybe<Order_By>;
  projectManagerId?: Maybe<Order_By>;
  tieckTypeId?: Maybe<Order_By>;
};

/** update columns of table "tickets" */
export enum Tickets_Update_Column {
  /** column name */
  ContractId = 'contractId',
  /** column name */
  Id = 'id',
  /** column name */
  OpeningDate = 'openingDate',
  /** column name */
  PaymentId = 'paymentId',
  /** column name */
  ProjectManagerId = 'projectManagerId',
  /** column name */
  TieckTypeId = 'tieckTypeId'
}

/** aggregate var_pop on columns */
export type Tickets_Var_Pop_Fields = {
  __typename?: 'tickets_var_pop_fields';
  contractId?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  paymentId?: Maybe<Scalars['Float']>;
  projectManagerId?: Maybe<Scalars['Float']>;
  tieckTypeId?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "tickets" */
export type Tickets_Var_Pop_Order_By = {
  contractId?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  paymentId?: Maybe<Order_By>;
  projectManagerId?: Maybe<Order_By>;
  tieckTypeId?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Tickets_Var_Samp_Fields = {
  __typename?: 'tickets_var_samp_fields';
  contractId?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  paymentId?: Maybe<Scalars['Float']>;
  projectManagerId?: Maybe<Scalars['Float']>;
  tieckTypeId?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "tickets" */
export type Tickets_Var_Samp_Order_By = {
  contractId?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  paymentId?: Maybe<Order_By>;
  projectManagerId?: Maybe<Order_By>;
  tieckTypeId?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Tickets_Variance_Fields = {
  __typename?: 'tickets_variance_fields';
  contractId?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  paymentId?: Maybe<Scalars['Float']>;
  projectManagerId?: Maybe<Scalars['Float']>;
  tieckTypeId?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "tickets" */
export type Tickets_Variance_Order_By = {
  contractId?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  paymentId?: Maybe<Order_By>;
  projectManagerId?: Maybe<Order_By>;
  tieckTypeId?: Maybe<Order_By>;
};


/** expression to compare columns of type timestamptz. All fields are combined with logical 'AND'. */
export type Timestamptz_Comparison_Exp = {
  _eq?: Maybe<Scalars['timestamptz']>;
  _gt?: Maybe<Scalars['timestamptz']>;
  _gte?: Maybe<Scalars['timestamptz']>;
  _in?: Maybe<Array<Scalars['timestamptz']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['timestamptz']>;
  _lte?: Maybe<Scalars['timestamptz']>;
  _neq?: Maybe<Scalars['timestamptz']>;
  _nin?: Maybe<Array<Scalars['timestamptz']>>;
};

export type GetProjectManagersQueryVariables = Exact<{ [key: string]: never; }>;


export type GetProjectManagersQuery = (
  { __typename?: 'query_root' }
  & { projectManagers: Array<(
    { __typename?: 'projectManagers' }
    & Pick<ProjectManagers, 'id' | 'name'>
  )> }
);

export type GetEntitiesQueryVariables = Exact<{ [key: string]: never; }>;


export type GetEntitiesQuery = (
  { __typename?: 'query_root' }
  & { entities: Array<(
    { __typename?: 'entities' }
    & Pick<Entities, 'email' | 'id' | 'idNumber' | 'letterAddress' | 'linkToS3' | 'phone'>
  )> }
);


export const GetProjectManagersDocument = `
    query getProjectManagers {
  projectManagers {
    id
    name
  }
}
    `;
export const useGetProjectManagersQuery = (dataSource: { endpoint: string, fetchParams?: RequestInit }, variables?: GetProjectManagersQueryVariables, options?: QueryConfig<GetProjectManagersQuery>) => 
  useQuery<GetProjectManagersQuery>(
    ['getProjectManagers', variables],
    fetcher<GetProjectManagersQuery, GetProjectManagersQueryVariables>(dataSource.endpoint, dataSource.fetchParams || {}, GetProjectManagersDocument, variables),
    options
  );
export const GetEntitiesDocument = `
    query getEntities {
  entities {
    email
    id
    idNumber
    letterAddress
    linkToS3
    phone
  }
}
    `;
export const useGetEntitiesQuery = (dataSource: { endpoint: string, fetchParams?: RequestInit }, variables?: GetEntitiesQueryVariables, options?: QueryConfig<GetEntitiesQuery>) => 
  useQuery<GetEntitiesQuery>(
    ['getEntities', variables],
    fetcher<GetEntitiesQuery, GetEntitiesQueryVariables>(dataSource.endpoint, dataSource.fetchParams || {}, GetEntitiesDocument, variables),
    options
  );